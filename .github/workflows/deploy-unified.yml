name: Deploy to Azure (VMSS + Web App)

on:
  workflow_dispatch:
    inputs:
      deployment_target:
        description: "ë°°í¬ ëŒ€ìƒ ì„ íƒ"
        required: true
        default: "both"
        type: choice
        options:
          - both
          - vmss-only
          - webapp-only
      environment:
        description: "ë°°í¬ í™˜ê²½"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - staging
          - prod
      image_tag:
        description: "ë°°í¬í•  ì´ë¯¸ì§€ íƒœê·¸ (ê¸°ë³¸: latest)"
        required: false
        type: string
        default: "latest"
  push:
    branches: [ "main" ]
    paths:
      - "Front-End/**"
      - "Back-End/**"
      - "infra/**"
      - ".github/workflows/deploy-unified.yml"

permissions:
  contents: read
  id-token: write
  actions: read

concurrency:
  group: deploy-${{ github.ref }}-${{ github.event.inputs.environment || 'dev' }}
  cancel-in-progress: false

env:
  AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
  AZURE_RG: rg-bcd00
  ACR_NAME: acrbcd00
  KV_NAME: kv-bcd00
  VMSS_BE: vmss-be-bcd00
  VMSS_FE: vmss-fe-bcd00
  WEBAPP_BE: webapp-be-bcd00
  WEBAPP_FE: webapp-fe-bcd00
  IMAGE_TAG: ${{ github.event.inputs.image_tag || 'latest' }}
  DEPLOYMENT_TARGET: ${{ github.event.inputs.deployment_target || 'both' }}
  ENVIRONMENT: ${{ github.event.inputs.environment || 'dev' }}

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      should_deploy_vmss: ${{ steps.targets.outputs.should_deploy_vmss }}
      should_deploy_webapp: ${{ steps.targets.outputs.should_deploy_webapp }}
      image_tag: ${{ steps.tags.outputs.image_tag }}
    steps:
      - name: Determine deployment targets
        id: targets
        run: |
          case "${{ env.DEPLOYMENT_TARGET }}" in
            "both")
              echo "should_deploy_vmss=true" >> $GITHUB_OUTPUT
              echo "should_deploy_webapp=true" >> $GITHUB_OUTPUT
              ;;
            "vmss-only")
              echo "should_deploy_vmss=true" >> $GITHUB_OUTPUT
              echo "should_deploy_webapp=false" >> $GITHUB_OUTPUT
              ;;
            "webapp-only")
              echo "should_deploy_vmss=false" >> $GITHUB_OUTPUT
              echo "should_deploy_webapp=true" >> $GITHUB_OUTPUT
              ;;
          esac
          
      - name: Set image tag
        id: tags
        run: |
          if [ "${{ env.IMAGE_TAG }}" = "latest" ] && [ "${{ github.event_name }}" = "push" ]; then
            SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
            echo "image_tag=sha-${SHORT_SHA}" >> $GITHUB_OUTPUT
          else
            echo "image_tag=${{ env.IMAGE_TAG }}" >> $GITHUB_OUTPUT
          fi

  build-and-push:
    runs-on: ubuntu-latest
    needs: setup
    environment: ${{ github.event.inputs.environment || 'dev' }}
    outputs:
      backend_image: ${{ steps.images.outputs.backend_image }}
      frontend_image: ${{ steps.images.outputs.frontend_image }}
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - uses: docker/setup-buildx-action@v3

      - name: ACR login
        run: az acr login --name ${{ env.ACR_NAME }}

      - name: Build and push backend
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile.backend
          push: true
          tags: |
            ${{ env.ACR_NAME }}.azurecr.io/backend:${{ needs.setup.outputs.image_tag }}
            ${{ env.ACR_NAME }}.azurecr.io/backend:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push frontend
        uses: docker/build-push-action@v6
        with:
          context: Front-End
          file: ./Dockerfile.frontend
          push: true
          tags: |
            ${{ env.ACR_NAME }}.azurecr.io/frontend:${{ needs.setup.outputs.image_tag }}
            ${{ env.ACR_NAME }}.azurecr.io/frontend:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Set image outputs
        id: images
        run: |
          echo "backend_image=${{ env.ACR_NAME }}.azurecr.io/backend:${{ needs.setup.outputs.image_tag }}" >> $GITHUB_OUTPUT
          echo "frontend_image=${{ env.ACR_NAME }}.azurecr.io/frontend:${{ needs.setup.outputs.image_tag }}" >> $GITHUB_OUTPUT

  check-vmss:
    runs-on: ubuntu-latest
    needs: [setup]
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: needs.setup.outputs.should_deploy_vmss == 'true'
    outputs:
      vmss_be_exists: ${{ steps.check.outputs.vmss_be_exists }}
      vmss_fe_exists: ${{ steps.check.outputs.vmss_fe_exists }}
      vmss_configured: ${{ steps.check.outputs.vmss_configured }}
    steps:
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Check VMSS existence
        id: check
        run: |
          echo "ðŸ” Checking VMSS existence..."
          
          # Check if Backend VMSS exists
          if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_BE }} >/dev/null 2>&1; then
            echo "âœ… Backend VMSS (${{ env.VMSS_BE }}) exists"
            echo "vmss_be_exists=true" >> $GITHUB_OUTPUT
            VMSS_BE_EXISTS=true
          else
            echo "âŒ Backend VMSS (${{ env.VMSS_BE }}) not found"
            echo "vmss_be_exists=false" >> $GITHUB_OUTPUT
            VMSS_BE_EXISTS=false
          fi
          
          # Check if Frontend VMSS exists
          if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_FE }} >/dev/null 2>&1; then
            echo "âœ… Frontend VMSS (${{ env.VMSS_FE }}) exists"
            echo "vmss_fe_exists=true" >> $GITHUB_OUTPUT
            VMSS_FE_EXISTS=true
          else
            echo "âŒ Frontend VMSS (${{ env.VMSS_FE }}) not found"
            echo "vmss_fe_exists=false" >> $GITHUB_OUTPUT
            VMSS_FE_EXISTS=false
          fi
          
          # Individual VMSS deployment decisions
          if [ "$VMSS_BE_EXISTS" = "false" ] || [ "$VMSS_FE_EXISTS" = "false" ]; then
            echo "âš ï¸ Some VMSS are missing - VMSS deployment will proceed"
            echo "vmss_configured=false" >> $GITHUB_OUTPUT
          else
            echo "âœ… All VMSS are configured - VMSS deployment will be skipped"
            echo "vmss_configured=true" >> $GITHUB_OUTPUT
          fi

  deploy-infrastructure:
    runs-on: ubuntu-latest
    needs: [setup, build-and-push, check-vmss]
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: needs.setup.outputs.should_deploy_vmss == 'true' && needs.check-vmss.outputs.vmss_configured == 'false'
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Deploy infrastructure (if needed)
        run: |
          echo "Infrastructure deployment step - implement based on your bicep/terraform files"
          # az deployment group create --resource-group ${{ env.AZURE_RG }} --template-file infra/main.bicep
          echo "Skipping infrastructure deployment - using existing resources"

  create-vmss:
    runs-on: ubuntu-latest
    needs: [setup, build-and-push, deploy-infrastructure, check-vmss, setup-agw-health-probes]
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: needs.setup.outputs.should_deploy_vmss == 'true' && needs.check-vmss.outputs.vmss_configured == 'false'
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Check existing Azure resources
        run: |
          echo "ðŸ” Checking existing Azure resources for VMSS deployment..."
          
          # Basic subnet checks (required for VMSS)
          if az network vnet subnet show --resource-group ${{ env.AZURE_RG }} --vnet-name vnet-eus2 --name snet-eus2-be >/dev/null 2>&1; then
            echo "âœ… Backend subnet (snet-eus2-be) exists"
          else
            echo "âŒ Backend subnet (snet-eus2-be) not found"
            exit 1
          fi
          
          if az network vnet subnet show --resource-group ${{ env.AZURE_RG }} --vnet-name vnet-eus2 --name snet-eus2-fe >/dev/null 2>&1; then
            echo "âœ… Frontend subnet (snet-eus2-fe) exists"
          else
            echo "âŒ Frontend subnet (snet-eus2-fe) not found"
            exit 1
          fi
          
          echo "âœ… Required networking resources verified for VMSS creation"

      - name: Create NSG with required rules (Enhanced)
        run: |
          echo "Creating NSGs for both Frontend and Backend VMSS with enhanced outbound rules..."
          
          # Create Backend NSG (skip if exists)
          if ! az network nsg show --resource-group ${{ env.AZURE_RG }} --name vmss-be-bcd00-nsg >/dev/null 2>&1; then
            echo "Creating Backend NSG..."
            az network nsg create \
              --resource-group ${{ env.AZURE_RG }} \
              --name vmss-be-bcd00-nsg \
              --location eastus2
          else
            echo "Backend NSG already exists"
          fi
          
          # Add inbound rule for port 4000 (backend application)
          az network nsg rule create \
            --resource-group ${{ env.AZURE_RG }} \
            --nsg-name vmss-be-bcd00-nsg \
            --name "Allow-AGW-Backend-4000" \
            --priority 1000 \
            --source-address-prefixes "172.16.0.0/27" \
            --destination-port-ranges "4000" \
            --access "Allow" \
            --protocol "Tcp" \
            --direction "Inbound" \
            || echo "Backend inbound NSG rule already exists"
          
          # Add critical outbound rules for ACR and Key Vault access
          az network nsg rule create \
            --resource-group ${{ env.AZURE_RG }} \
            --nsg-name vmss-be-bcd00-nsg \
            --name "Allow-HTTPS-Outbound" \
            --priority 100 \
            --source-address-prefixes "*" \
            --destination-address-prefixes "Internet" \
            --destination-port-ranges "443" \
            --access "Allow" \
            --protocol "Tcp" \
            --direction "Outbound" \
            || echo "HTTPS outbound rule already exists"
          
          # Add rule for Azure services (ACR, Key Vault, etc.)
          az network nsg rule create \
            --resource-group ${{ env.AZURE_RG }} \
            --nsg-name vmss-be-bcd00-nsg \
            --name "Allow-Azure-Services" \
            --priority 110 \
            --source-address-prefixes "*" \
            --destination-address-prefixes "AzureContainerRegistry" \
            --destination-port-ranges "443" \
            --access "Allow" \
            --protocol "Tcp" \
            --direction "Outbound" \
            || echo "Azure services outbound rule already exists"
          
          # Add rule for Key Vault access
          az network nsg rule create \
            --resource-group ${{ env.AZURE_RG }} \
            --nsg-name vmss-be-bcd00-nsg \
            --name "Allow-KeyVault-Access" \
            --priority 120 \
            --source-address-prefixes "*" \
            --destination-address-prefixes "AzureKeyVault" \
            --destination-port-ranges "443" \
            --access "Allow" \
            --protocol "Tcp" \
            --direction "Outbound" \
            || echo "Key Vault outbound rule already exists"
          
          # Create Frontend NSG (skip if exists)
          if ! az network nsg show --resource-group ${{ env.AZURE_RG }} --name vmss-fe-bcd00-nsg >/dev/null 2>&1; then
            echo "Creating Frontend NSG..."
            az network nsg create \
              --resource-group ${{ env.AZURE_RG }} \
              --name vmss-fe-bcd00-nsg \
              --location eastus2
          else
            echo "Frontend NSG already exists"
          fi
          
          # Add rule for port 80 (frontend application)
          az network nsg rule create \
            --resource-group ${{ env.AZURE_RG }} \
            --nsg-name vmss-fe-bcd00-nsg \
            --name "Allow-AGW-Frontend-80" \
            --priority 1000 \
            --source-address-prefixes "172.16.0.0/27" \
            --destination-port-ranges "80" \
            --access "Allow" \
            --protocol "Tcp" \
            --direction "Inbound" \
            || echo "Frontend NSG rule already exists"
          
          # Add SSH rules for both
          for nsg in "vmss-be-bcd00-nsg" "vmss-fe-bcd00-nsg"; do
            az network nsg rule create \
              --resource-group ${{ env.AZURE_RG }} \
              --nsg-name "$nsg" \
              --name "Allow-SSH" \
              --priority 1001 \
              --source-address-prefixes "*" \
              --destination-port-ranges "22" \
              --access "Allow" \
              --protocol "Tcp" \
              --direction "Inbound" \
              || echo "SSH rule already exists for $nsg"
          done

      - name: Create SSH Keys
        run: |
          echo "Creating SSH Keys for both VMSS..."
          
          # Create Backend SSH Key (skip if exists)
          if ! az sshkey show --resource-group ${{ env.AZURE_RG }} --name vmss-be-bcd00_key >/dev/null 2>&1; then
            echo "Creating Backend SSH key..."
            az sshkey create \
              --resource-group ${{ env.AZURE_RG }} \
              --name vmss-be-bcd00_key \
              --location eastus2
          else
            echo "Backend SSH key already exists"
          fi
          
          # Create Frontend SSH Key (skip if exists)
          if ! az sshkey show --resource-group ${{ env.AZURE_RG }} --name vmss-fe-bcd00_key >/dev/null 2>&1; then
            echo "Creating Frontend SSH key..."
            az sshkey create \
              --resource-group ${{ env.AZURE_RG }} \
              --name vmss-fe-bcd00_key \
              --location eastus2
          else
            echo "Frontend SSH key already exists"
          fi

      - name: Create VMSS instances (Enhanced with Auto Managed Identity)
        run: |
          echo "ðŸ—ï¸ Creating Frontend and Backend VMSS with automatic managed identity setup..."
          
          # Create User-assigned Managed Identities first
          echo "Creating User-assigned Managed Identities..."
          if ! az identity show --resource-group ${{ env.AZURE_RG }} --name id-vmss-be-bcd00 >/dev/null 2>&1; then
            echo "Creating Backend Managed Identity..."
            az identity create --resource-group ${{ env.AZURE_RG }} --name id-vmss-be-bcd00 --location eastus2
            
            # Wait for identity to be ready
            sleep 15
          else
            echo "Backend Managed Identity already exists"
          fi
          
          if ! az identity show --resource-group ${{ env.AZURE_RG }} --name id-vmss-fe-bcd00 >/dev/null 2>&1; then
            echo "Creating Frontend Managed Identity..."
            az identity create --resource-group ${{ env.AZURE_RG }} --name id-vmss-fe-bcd00 --location eastus2
            
            # Wait for identity to be ready
            sleep 15
          else
            echo "Frontend Managed Identity already exists"
          fi
          
          # Get identity resource IDs for both user-assigned and system-assigned
          VMSS_BE_IDENTITY_ID=$(az identity show --resource-group ${{ env.AZURE_RG }} --name id-vmss-be-bcd00 --query "id" -o tsv)
          VMSS_FE_IDENTITY_ID=$(az identity show --resource-group ${{ env.AZURE_RG }} --name id-vmss-fe-bcd00 --query "id" -o tsv)
          
          echo "Backend Identity ID: $VMSS_BE_IDENTITY_ID"
          echo "Frontend Identity ID: $VMSS_FE_IDENTITY_ID"
          
          # Create Backend VMSS only if it doesn't exist
          echo "ðŸ” Checking Backend VMSS existence..."
          if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_BE }} >/dev/null 2>&1; then
            echo "âœ… Backend VMSS already exists, skipping creation"
          else
            echo "âŒ Backend VMSS not found, will create"
            
            # Wait for any pending operations to complete
            echo "â³ Waiting for any pending operations..."
            sleep 30
            
            # Double-check before creating
            if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_BE }} >/dev/null 2>&1; then
              echo "âœ… Backend VMSS appeared during wait, skipping creation"
            else
              echo "Creating Backend VMSS with both user-assigned and system-assigned identities..."
              az vmss create \
                --resource-group ${{ env.AZURE_RG }} \
                --name ${{ env.VMSS_BE }} \
                --image "Canonical:0001-com-ubuntu-server-jammy:22_04-lts-gen2:latest" \
                --instance-count 2 \
                --vm-sku Standard_B2s \
                --vnet-name vnet-eus2 \
                --subnet snet-eus2-be \
                --nsg vmss-be-bcd00-nsg \
                --orchestration-mode Uniform \
                --upgrade-policy-mode automatic \
                --admin-username bcdbeuser00 \
                --generate-ssh-keys \
                --custom-data infra/cloud-init-optimized.yaml \
                --assign-identity "$VMSS_BE_IDENTITY_ID" \
                --load-balancer nlb-bcd00 \
                --backend-pool-name backend-lb-pool \
                --health-probe "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.AZURE_RG }}/providers/Microsoft.Network/loadBalancers/nlb-bcd00/probes/probe-for-port-4000" \
                --location eastus2
              
              # Also enable system-assigned identity for additional compatibility
              echo "Enabling system-assigned managed identity for Backend VMSS..."
              az vmss identity assign \
                --resource-group ${{ env.AZURE_RG }} \
                --name ${{ env.VMSS_BE }} \
                --identities [system]
              
              echo "âœ… Backend VMSS created successfully with dual identity setup"
            fi
          fi
          
          # Create Frontend VMSS only if it doesn't exist
          echo "ðŸ” Checking Frontend VMSS existence..."
          if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_FE }} >/dev/null 2>&1; then
            echo "âœ… Frontend VMSS already exists, skipping creation"
          else
            echo "âŒ Frontend VMSS not found, will create"
            
            # Wait for any pending operations to complete
            echo "â³ Waiting for any pending operations..."
            sleep 30
            
            # Double-check before creating
            if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_FE }} >/dev/null 2>&1; then
              echo "âœ… Frontend VMSS appeared during wait, skipping creation"
            else
              echo "Creating Frontend VMSS with both user-assigned and system-assigned identities..."
              az vmss create \
                --resource-group ${{ env.AZURE_RG }} \
                --name ${{ env.VMSS_FE }} \
                --image "Canonical:0001-com-ubuntu-server-jammy:22_04-lts-gen2:latest" \
                --instance-count 2 \
                --vm-sku Standard_B2s \
                --vnet-name vnet-eus2 \
                --subnet snet-eus2-fe \
                --nsg vmss-fe-bcd00-nsg \
                --orchestration-mode Uniform \
                --upgrade-policy-mode automatic \
                --admin-username bcdfeuser00 \
                --generate-ssh-keys \
                --custom-data infra/cloud-init-frontend.yaml \
                --assign-identity "$VMSS_FE_IDENTITY_ID" \
                --load-balancer "" \
                --location eastus2
              
              # Also enable system-assigned identity for additional compatibility
              echo "Enabling system-assigned managed identity for Frontend VMSS..."
              az vmss identity assign \
                --resource-group ${{ env.AZURE_RG }} \
                --name ${{ env.VMSS_FE }} \
                --identities [system]
              
              echo "âœ… Frontend VMSS created successfully with dual identity setup"
            fi
          fi

      - name: Validate and Re-assign Permissions (Comprehensive)
        run: |
          echo "ï¿½ Comprehensive permission validation and assignment..."
          
          # Wait for identities to propagate fully
          sleep 30
          
          # Function to get all identity IDs for a VMSS
          get_vmss_identities() {
            local vmss_name="$1"
            local rg="$2"
            
            # Get user-assigned identity
            USER_IDENTITY=$(az identity show --resource-group "$rg" --name "id-$vmss_name" --query "principalId" -o tsv 2>/dev/null || echo "")
            
            # Get system-assigned identity
            SYSTEM_IDENTITY=$(az vmss show --resource-group "$rg" --name "$vmss_name" --query "identity.principalId" -o tsv 2>/dev/null || echo "")
            
            echo "USER_IDENTITY:$USER_IDENTITY SYSTEM_IDENTITY:$SYSTEM_IDENTITY"
          }
          
          # Function to assign ACR permissions
          assign_acr_permissions() {
            local identity_id="$1"
            local identity_type="$2"
            local vmss_name="$3"
            
            if [ -n "$identity_id" ] && [ "$identity_id" != "null" ]; then
              echo "Assigning ACR permissions to $identity_type identity ($identity_id) for $vmss_name..."
              
              # AcrPull role
              az role assignment create \
                --assignee "$identity_id" \
                --role "AcrPull" \
                --scope "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.AZURE_RG }}/providers/Microsoft.ContainerRegistry/registries/${{ env.ACR_NAME }}" \
                || echo "AcrPull role already assigned or failed"
              
              # AcrImageSigner for token exchange compatibility
              az role assignment create \
                --assignee "$identity_id" \
                --role "AcrImageSigner" \
                --scope "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.AZURE_RG }}/providers/Microsoft.ContainerRegistry/registries/${{ env.ACR_NAME }}" \
                || echo "AcrImageSigner role assignment skipped"
              
              # Verify assignments
              echo "Verifying ACR role assignments for $identity_type identity:"
              az role assignment list \
                --assignee "$identity_id" \
                --scope "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.AZURE_RG }}/providers/Microsoft.ContainerRegistry/registries/${{ env.ACR_NAME }}" \
                --query "[].roleDefinitionName" -o tsv | sed 's/^/   - /'
              
              return 0
            else
              echo "Warning: No valid $identity_type identity found for $vmss_name"
              return 1
            fi
          }
          
          # Function to assign Key Vault permissions
          assign_keyvault_permissions() {
            local identity_id="$1"
            local identity_type="$2"
            local vmss_name="$3"
            
            if [ -n "$identity_id" ] && [ "$identity_id" != "null" ]; then
              # Find Key Vault
              KV_NAME=$(az keyvault list --resource-group ${{ env.AZURE_RG }} --query "[0].name" -o tsv 2>/dev/null || echo "")
              
              if [ -n "$KV_NAME" ] && [ "$KV_NAME" != "null" ]; then
                echo "Assigning Key Vault permissions to $identity_type identity for $vmss_name..."
                
                # RBAC role assignment
                az role assignment create \
                  --assignee "$identity_id" \
                  --role "Key Vault Secrets User" \
                  --scope "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.AZURE_RG }}/providers/Microsoft.KeyVault/vaults/$KV_NAME" \
                  || echo "Key Vault RBAC role already assigned"
                
                # Access policy for backward compatibility
                az keyvault set-policy \
                  --name "$KV_NAME" \
                  --object-id "$identity_id" \
                  --secret-permissions get list \
                  || echo "Key Vault access policy already set"
                
                echo "âœ… Key Vault permissions configured for $identity_type identity"
              else
                echo "âš ï¸ Key Vault not found, skipping Key Vault permissions"
              fi
            fi
          }
          
          # Process Backend VMSS identities
          echo "ðŸ” Processing Backend VMSS identities..."
          BACKEND_IDENTITIES=$(get_vmss_identities "${{ env.VMSS_BE }}" "${{ env.AZURE_RG }}")
          USER_BE_ID=$(echo "$BACKEND_IDENTITIES" | cut -d' ' -f1 | cut -d':' -f2)
          SYSTEM_BE_ID=$(echo "$BACKEND_IDENTITIES" | cut -d' ' -f2 | cut -d':' -f2)
          
          echo "Backend User Identity: $USER_BE_ID"
          echo "Backend System Identity: $SYSTEM_BE_ID"
          
          # Assign permissions to both identities for maximum compatibility
          BACKEND_SUCCESS=0
          if assign_acr_permissions "$USER_BE_ID" "user-assigned" "${{ env.VMSS_BE }}"; then
            assign_keyvault_permissions "$USER_BE_ID" "user-assigned" "${{ env.VMSS_BE }}"
            BACKEND_SUCCESS=1
          fi
          
          if assign_acr_permissions "$SYSTEM_BE_ID" "system-assigned" "${{ env.VMSS_BE }}"; then
            assign_keyvault_permissions "$SYSTEM_BE_ID" "system-assigned" "${{ env.VMSS_BE }}"
            BACKEND_SUCCESS=1
          fi
          
          if [ $BACKEND_SUCCESS -eq 0 ]; then
            echo "âŒ Failed to assign permissions to Backend VMSS"
            exit 1
          else
            echo "âœ… Backend VMSS permissions configured successfully"
          fi
          
          # Process Frontend VMSS identities
          echo "ðŸ” Processing Frontend VMSS identities..."
          FRONTEND_IDENTITIES=$(get_vmss_identities "${{ env.VMSS_FE }}" "${{ env.AZURE_RG }}")
          USER_FE_ID=$(echo "$FRONTEND_IDENTITIES" | cut -d' ' -f1 | cut -d':' -f2)
          SYSTEM_FE_ID=$(echo "$FRONTEND_IDENTITIES" | cut -d' ' -f2 | cut -d':' -f2)
          
          echo "Frontend User Identity: $USER_FE_ID"
          echo "Frontend System Identity: $SYSTEM_FE_ID"
          
          # Assign permissions to both identities for maximum compatibility
          FRONTEND_SUCCESS=0
          if assign_acr_permissions "$USER_FE_ID" "user-assigned" "${{ env.VMSS_FE }}"; then
            assign_keyvault_permissions "$USER_FE_ID" "user-assigned" "${{ env.VMSS_FE }}"
            FRONTEND_SUCCESS=1
          fi
          
          if assign_acr_permissions "$SYSTEM_FE_ID" "system-assigned" "${{ env.VMSS_FE }}"; then
            assign_keyvault_permissions "$SYSTEM_FE_ID" "system-assigned" "${{ env.VMSS_FE }}"
            FRONTEND_SUCCESS=1
          fi
          
          if [ $FRONTEND_SUCCESS -eq 0 ]; then
            echo "âš ï¸ Warning: Could not assign permissions to Frontend VMSS (may affect image pulling)"
          else
            echo "âœ… Frontend VMSS permissions configured successfully"
          fi
          
          echo ""
          echo "ðŸ“‹ Permission Assignment Summary:"
          echo "Backend VMSS: $([ $BACKEND_SUCCESS -eq 1 ] && echo "âœ… Success" || echo "âŒ Failed")"
          echo "Frontend VMSS: $([ $FRONTEND_SUCCESS -eq 1 ] && echo "âœ… Success" || echo "âš ï¸ Partial")"

      - name: Configure Application Gateway Backend Pools
        run: |
          echo "Configuring Application Gateway backend pools..."
          
          # Wait for VMSS to be fully ready
          sleep 30
          
          # Create backend pool for API calls (routed to load balancer)
          az network application-gateway address-pool create \
            --resource-group ${{ env.AZURE_RG }} \
            --gateway-name agw-bcd00 \
            --name backend-pool \
            || echo "Backend pool already exists"
          
          # Create frontend pool for web traffic (directly to frontend VMSS)
          az network application-gateway address-pool create \
            --resource-group ${{ env.AZURE_RG }} \
            --gateway-name agw-bcd00 \
            --name frontend-pool \
            || echo "Frontend pool already exists"
          
          # Configure routing rules
          echo "Configuring Application Gateway routing rules..."
          
          # Create HTTP settings for backend (port 4000 through load balancer)
          az network application-gateway http-settings create \
            --resource-group ${{ env.AZURE_RG }} \
            --gateway-name agw-bcd00 \
            --name setting-for-backend \
            --port 4000 \
            --protocol Http \
            --cookie-based-affinity Disabled \
            || echo "Backend HTTP settings already exist"
          
          # Create HTTP settings for frontend (port 80 direct to VMSS)
          az network application-gateway http-settings create \
            --resource-group ${{ env.AZURE_RG }} \
            --gateway-name agw-bcd00 \
            --name setting-for-frontend \
            --port 80 \
            --protocol Http \
            --cookie-based-affinity Disabled \
            || echo "Frontend HTTP settings already exist"
          
          # Create URL path map for routing with default path to frontend
          az network application-gateway url-path-map create \
            --resource-group ${{ env.AZURE_RG }} \
            --gateway-name agw-bcd00 \
            --name rule-path-based \
            --paths "/*" \
            --address-pool frontend-pool \
            --http-settings setting-for-frontend \
            --default-address-pool frontend-pool \
            --default-http-settings setting-for-frontend \
            || echo "URL path map already exists"
          
          # Add path rule for /api/* to backend (through load balancer)
          az network application-gateway url-path-map rule create \
            --resource-group ${{ env.AZURE_RG }} \
            --gateway-name agw-bcd00 \
            --path-map-name rule-path-based \
            --name target-backend \
            --paths "/api/*" \
            --address-pool backend-pool \
            --http-settings setting-for-backend \
            || echo "Backend path rule already exists"
            
          # Configure Frontend VMSS â†’ Application Gateway direct connection
          echo "Configuring Frontend VMSS â†’ Application Gateway direct connection..."
          
          # Check if Frontend VMSS exists and has instances
          if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_FE }} >/dev/null 2>&1; then
            # Get Frontend VMSS instance private IPs
            FRONTEND_IPS=$(az vmss nic list \
              --resource-group ${{ env.AZURE_RG }} \
              --vmss-name ${{ env.VMSS_FE }} \
              --query "[].ipConfigurations[0].privateIPAddress" -o tsv | tr '\n' ' ')
            
            if [ -n "$FRONTEND_IPS" ]; then
              echo "Adding Frontend VMSS IPs ($FRONTEND_IPS) to frontend pool"
              az network application-gateway address-pool update \
                --resource-group ${{ env.AZURE_RG }} \
                --gateway-name agw-bcd00 \
                --name frontend-pool \
                --servers $FRONTEND_IPS \
                || echo "Frontend IPs already added to frontend pool"
              echo "âœ… Frontend VMSS â†’ Application Gateway connection configured"
            else
              echo "âš ï¸ Could not find Frontend VMSS instance IPs"
            fi
          else
            echo "âš ï¸ Frontend VMSS not found, skipping direct connection"
          fi
          
          # Configure Backend API routing: Application Gateway â†’ Load Balancer â†’ Backend VMSS
          echo "Configuring Application Gateway â†’ Load Balancer â†’ Backend VMSS routing..."
          
          # Add load balancer frontend IP to backend pool
          NLB_FRONTEND_IP=$(az network lb frontend-ip list \
            --resource-group ${{ env.AZURE_RG }} \
            --lb-name nlb-bcd00 \
            --query "[0].privateIPAddress" -o tsv)
          
          if [ -n "$NLB_FRONTEND_IP" ] && [ "$NLB_FRONTEND_IP" != "null" ]; then
            echo "Adding Load Balancer frontend IP ($NLB_FRONTEND_IP) to backend pool"
            az network application-gateway address-pool update \
              --resource-group ${{ env.AZURE_RG }} \
              --gateway-name agw-bcd00 \
              --name backend-pool \
              --servers "$NLB_FRONTEND_IP" \
              || echo "Load balancer IP already added to backend pool"
            echo "âœ… Application Gateway â†’ Load Balancer â†’ Backend VMSS routing configured"
          else
            echo "âš ï¸ Could not find load balancer frontend IP"
          fi
          
          echo "ðŸ“Š Application Gateway Configuration Summary:"
          echo "  ðŸ”¸ Frontend Traffic: Application Gateway â†’ Frontend VMSS (direct)"
          echo "  ðŸ”¸ Backend API Traffic: Application Gateway â†’ Load Balancer â†’ Backend VMSS"
          echo "  ðŸ”¸ Routing: /* â†’ Frontend Pool, /api/* â†’ Backend Pool"

  create-application-gateway:
    runs-on: ubuntu-latest
    needs: [setup, build-and-push, deploy-infrastructure, check-vmss]
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: needs.setup.outputs.should_deploy_vmss == 'true' && needs.check-vmss.outputs.vmss_configured == 'false'
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Check and create Application Gateway if needed
        run: |
          echo "ðŸŒ Checking Application Gateway requirements..."
          
          # Check if Application Gateway subnet exists
          if az network vnet subnet show --resource-group ${{ env.AZURE_RG }} --vnet-name vnet-eus2 --name snet-eus2-agw >/dev/null 2>&1; then
            echo "âœ… Application Gateway subnet (snet-eus2-agw) exists"
            
            # Check if Application Gateway already exists
            if az network application-gateway show --resource-group ${{ env.AZURE_RG }} --name agw-bcd00 >/dev/null 2>&1; then
              echo "âœ… Application Gateway (agw-bcd00) already exists"
              echo "AGW_EXISTS=true" >> $GITHUB_ENV
            else
              echo "âš ï¸ Application Gateway (agw-bcd00) not found - will create"
              echo "AGW_EXISTS=false" >> $GITHUB_ENV
              
              # Create Public IP for Application Gateway
              echo "Creating Public IP for Application Gateway..."
              az network public-ip create \
                --resource-group ${{ env.AZURE_RG }} \
                --name pip-agw-bcd00 \
                --allocation-method Static \
                --sku Standard \
                --location eastus2 \
                || echo "Public IP already exists"
              
              # Create Application Gateway
              echo "Creating Application Gateway..."
              az network application-gateway create \
                --resource-group ${{ env.AZURE_RG }} \
                --name agw-bcd00 \
                --location eastus2 \
                --sku Standard_v2 \
                --capacity 2 \
                --vnet-name vnet-eus2 \
                --subnet snet-eus2-agw \
                --public-ip-address pip-agw-bcd00 \
                --http-settings-cookie-based-affinity Enabled \
                --frontend-port 80 \
                --http-settings-port 80 \
                --http-settings-protocol Http \
                --priority 100
              
              echo "âœ… Application Gateway created successfully"
              echo "AGW_EXISTS=true" >> $GITHUB_ENV
            fi
          else
            echo "âš ï¸ Application Gateway subnet (snet-eus2-agw) not found - will skip Application Gateway creation"
            echo "AGW_EXISTS=false" >> $GITHUB_ENV
          fi

  setup-agw-health-probes:
    if: ${{ inputs.deployment_target == 'vmss-only' || inputs.deployment_target == 'both' }}
    needs: [create-application-gateway]
    runs-on: ubuntu-latest
    
    steps:
    - name: ì²´í¬ì•„ì›ƒ
      uses: actions/checkout@v4
    
    - name: Azure ë¡œê·¸ì¸
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
    
    - name: Application Gateway Health Probe ì„¤ì •
      run: |
        echo "ðŸ¥ Application Gateway Health Probe ì„¤ì • ì¤‘..."
        
        # ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰ ê¶Œí•œ ë¶€ì—¬
        chmod +x scripts/create-agw-health-probe.sh
        
        # Health Probe ìƒì„± ì‹¤í–‰
        scripts/create-agw-health-probe.sh ${{ env.AZURE_RG }} agw-bcd00 || {
          echo "âš ï¸ Health Probe ì„¤ì •ì— ì‹¤íŒ¨í–ˆì§€ë§Œ ë°°í¬ë¥¼ ê³„ì†í•©ë‹ˆë‹¤."
        }
        
        echo "âœ… Application Gateway Health Probe ì„¤ì • ì™„ë£Œ"

  deploy-vmss:
    runs-on: ubuntu-latest
    needs: [setup, build-and-push, deploy-infrastructure, create-vmss, check-vmss]
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: needs.setup.outputs.should_deploy_vmss == 'true' && needs.check-vmss.outputs.vmss_configured == 'false'
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Update VMSS with optimized cloud-init
        run: |
          echo "ðŸ”„ Updating Frontend and Backend VMSS models with cloud-init..."
          
          # Update Backend VMSS if it exists
          if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_BE }} >/dev/null 2>&1; then
            echo "Updating Backend VMSS rolling upgrade policy..."
            az vmss update \
              --resource-group ${{ env.AZURE_RG }} \
              --name ${{ env.VMSS_BE }} \
              --set upgradePolicy.mode=Rolling \
              --set upgradePolicy.rollingUpgradePolicy.maxBatchInstancePercent=50 \
              --set upgradePolicy.rollingUpgradePolicy.maxUnhealthyInstancePercent=100 \
              --set upgradePolicy.rollingUpgradePolicy.maxUnhealthyUpgradedInstancePercent=100 \
              --set upgradePolicy.rollingUpgradePolicy.pauseTimeBetweenBatches=PT30S

            echo "Updating Backend VMSS model with new cloud-init..."
            az vmss update \
              --resource-group ${{ env.AZURE_RG }} \
              --name ${{ env.VMSS_BE }} \
              --set virtualMachineProfile.osProfile.customData="$(base64 -w 0 < infra/cloud-init-optimized.yaml)"
            
            echo "âœ… Backend VMSS model updated"
          else
            echo "âš ï¸ Backend VMSS not found, skipping update"
          fi
          
          # Update Frontend VMSS if it exists
          if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_FE }} >/dev/null 2>&1; then
            echo "Adding Application Health Extension to Frontend VMSS..."
            az vmss extension set \
              --resource-group ${{ env.AZURE_RG }} \
              --vmss-name ${{ env.VMSS_FE }} \
              --name ApplicationHealthLinux \
              --publisher Microsoft.ManagedServices \
              --version 1.0 \
              --settings '{"protocol":"http","port":80,"requestPath":"/"}' \
              || echo "Application Health Extension already exists"

            echo "Updating Frontend VMSS upgrade policy to Manual (Rolling requires health probe)..."
            az vmss update \
              --resource-group ${{ env.AZURE_RG }} \
              --name ${{ env.VMSS_FE }} \
              --set upgradePolicy.mode=Manual

            echo "Updating Frontend VMSS model with new cloud-init..."
            az vmss update \
              --resource-group ${{ env.AZURE_RG }} \
              --name ${{ env.VMSS_FE }} \
              --set virtualMachineProfile.osProfile.customData="$(base64 -w 0 < infra/cloud-init-frontend.yaml)"
              
            echo "âœ… Frontend VMSS model updated"
          else
            echo "âš ï¸ Frontend VMSS not found, skipping update"
          fi

      - name: Rolling upgrade VMSS instances
        run: |
          echo "ðŸ”„ Starting rolling upgrade of VMSS instances..."
          
          # Upgrade Backend VMSS if it exists
          if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_BE }} >/dev/null 2>&1; then
            echo "Upgrading Backend VMSS..."
            az vmss rolling-upgrade start \
              --resource-group ${{ env.AZURE_RG }} \
              --name ${{ env.VMSS_BE }} \
              || {
                echo "Rolling upgrade failed for Backend VMSS, trying instance-by-instance update..."
                INSTANCE_IDS=$(az vmss list-instances --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_BE }} --query "[].instanceId" -o tsv)
                for instance_id in $INSTANCE_IDS; do
                  echo "Updating Backend VMSS instance $instance_id..."
                  az vmss update-instances \
                    --resource-group ${{ env.AZURE_RG }} \
                    --name ${{ env.VMSS_BE }} \
                    --instance-ids $instance_id
                  sleep 30
                done
              }
            echo "âœ… Backend VMSS upgrade completed"
          else
            echo "âš ï¸ Backend VMSS not found, skipping upgrade"
          fi
          
          # Upgrade Frontend VMSS if it exists
          if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_FE }} >/dev/null 2>&1; then
            echo "Upgrading Frontend VMSS..."
            az vmss rolling-upgrade start \
              --resource-group ${{ env.AZURE_RG }} \
              --name ${{ env.VMSS_FE }} \
              || {
                echo "Rolling upgrade failed for Frontend VMSS, trying instance-by-instance update..."
                INSTANCE_IDS=$(az vmss list-instances --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_FE }} --query "[].instanceId" -o tsv)
                for instance_id in $INSTANCE_IDS; do
                  echo "Updating Frontend VMSS instance $instance_id..."
                  az vmss update-instances \
                    --resource-group ${{ env.AZURE_RG }} \
                    --name ${{ env.VMSS_FE }} \
                    --instance-ids $instance_id
                  sleep 30
                done
              }
            echo "âœ… Frontend VMSS upgrade completed"
          else
            echo "âš ï¸ Frontend VMSS not found, skipping upgrade"
          fi

      - name: Deploy new image to VMSS (Enhanced with diagnostics)
        run: |
          echo "ðŸš€ Deploying image ${{ needs.setup.outputs.image_tag }} to VMSS instances with enhanced diagnostics..."
          
          # Deploy to Backend VMSS if it exists
          if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_BE }} >/dev/null 2>&1; then
            echo "Deploying to Backend VMSS with comprehensive health checks..."
            
            # Get all instance IDs
            INSTANCE_IDS=$(az vmss list-instances --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_BE }} --query "[].instanceId" -o tsv)
            
            if [ -n "$INSTANCE_IDS" ]; then
              for instance_id in $INSTANCE_IDS; do
                echo "Deploying to Backend VMSS instance $instance_id..."
                az vmss run-command invoke \
                  --resource-group ${{ env.AZURE_RG }} \
                  --name ${{ env.VMSS_BE }} \
                  --instance-id "$instance_id" \
                  --command-id RunShellScript \
                  --scripts "
                    set -e
                    echo '=== Backend VMSS Instance Update Start (Instance: $instance_id) ==='
                    echo 'IMAGE_TAG=${{ needs.setup.outputs.image_tag }}'
                    echo 'Host: \$(hostname)'
                    echo 'Date: \$(date)'
                    
                    # Check Managed Identity
                    echo '=== Managed Identity Check ==='
                    MI_TOKEN=\$(curl -s -H 'Metadata:true' 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/' | jq -r .access_token 2>/dev/null || echo 'FAILED')
                    if [ \"\$MI_TOKEN\" != \"FAILED\" ] && [ -n \"\$MI_TOKEN\" ]; then
                      echo 'âœ… Managed Identity token acquired'
                    else
                      echo 'âŒ Managed Identity token acquisition failed'
                    fi
                    
                    # Check ACR connectivity and authentication
                    echo '=== ACR Connectivity Check ==='
                    if nslookup ${{ env.ACR_NAME }}.azurecr.io >/dev/null 2>&1; then
                      echo 'âœ… ACR DNS resolution successful'
                    else
                      echo 'âŒ ACR DNS resolution failed'
                    fi
                    
                    if curl -sSf https://${{ env.ACR_NAME }}.azurecr.io/v2/ >/dev/null 2>&1; then
                      echo 'âœ… ACR HTTPS connectivity successful'
                    else
                      echo 'âŒ ACR HTTPS connectivity failed'
                    fi
                    
                    # Test ACR authentication
                    echo '=== ACR Authentication Test ==='
                    ACR_TOKEN=\$(curl -s -H 'Metadata:true' 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://${{ env.ACR_NAME }}.azurecr.io' | jq -r .access_token 2>/dev/null || echo '')
                    if [ -n \"\$ACR_TOKEN\" ] && [ \"\$ACR_TOKEN\" != \"null\" ]; then
                      echo 'âœ… ACR-specific token acquired'
                      if echo \"\$ACR_TOKEN\" | sudo docker login ${{ env.ACR_NAME }}.azurecr.io --username 00000000-0000-0000-0000-000000000000 --password-stdin; then
                        echo 'âœ… ACR authentication successful'
                      else
                        echo 'âš ï¸ ACR authentication failed, trying fallback...'
                        # Fallback to management token
                        if [ \"\$MI_TOKEN\" != \"FAILED\" ]; then
                          echo \"\$MI_TOKEN\" | sudo docker login ${{ env.ACR_NAME }}.azurecr.io --username 00000000-0000-0000-0000-000000000000 --password-stdin || echo 'âŒ Fallback authentication failed'
                        fi
                      fi
                    else
                      echo 'âš ï¸ Direct ACR token failed, using management token...'
                      if [ \"\$MI_TOKEN\" != \"FAILED\" ]; then
                        echo \"\$MI_TOKEN\" | sudo docker login ${{ env.ACR_NAME }}.azurecr.io --username 00000000-0000-0000-0000-000000000000 --password-stdin || echo 'âŒ Management token authentication failed'
                      fi
                    fi
                    
                    # Set environment variable
                    export IMAGE_TAG=${{ needs.setup.outputs.image_tag }}
                    echo 'IMAGE_TAG=${{ needs.setup.outputs.image_tag }}' | sudo tee -a /opt/yangju/.env
                    
                    # Pull new images and restart service
                    cd /opt/yangju
                    sudo systemctl stop yangju.service || true
                    
                    echo '=== Pulling new images ==='
                    sudo /usr/local/bin/yangju-compose-run.sh pull || {
                      echo 'âŒ Image pull failed, checking logs...'
                      sudo docker images | grep ${{ env.ACR_NAME }} || echo 'No ACR images found'
                      sudo journalctl -u docker -n 20 --no-pager || true
                      exit 1
                    }
                    
                    sudo systemctl start yangju.service
                    
                    # Wait for health check
                    echo '=== Application Health Check ==='
                    for i in {1..30}; do
                      if curl -fsS http://localhost:4000/health >/dev/null 2>&1; then
                        echo 'âœ… Backend health check passed after '\$i' attempts'
                        curl -s http://localhost:4000/health | jq . || echo 'Health endpoint returned non-JSON'
                        break
                      elif [ \$i -eq 30 ]; then
                        echo 'âŒ Backend health check failed after 30 attempts'
                        echo 'Container logs:'
                        sudo docker logs yangju-backend --tail 50 || echo 'No container logs available'
                        echo 'Service status:'
                        sudo systemctl status yangju.service || true
                        exit 1
                      else
                        echo 'Waiting for backend health check... ('\$i'/30)'
                        sleep 2
                      fi
                    done
                    
                    sudo docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}'
                    echo '=== Backend VMSS Instance Update Complete ==='
                  " \
                  --query 'value[].message' -o tsv || echo "âŒ Instance $instance_id deployment failed"
                  
                echo "âœ… Backend VMSS instance $instance_id deployment completed"
                sleep 10  # Instance ê°„ ê°„ê²©
              done
            else
              echo "âŒ No running instances found in Backend VMSS"
            fi
          else
            echo "âš ï¸ Backend VMSS not found, skipping deployment"
          fi
          
          # Deploy to Frontend VMSS if it exists
          if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_FE }} >/dev/null 2>&1; then
            echo "Deploying to Frontend VMSS..."
            az vmss run-command invoke \
              --resource-group ${{ env.AZURE_RG }} \
              --name ${{ env.VMSS_FE }} \
              --instance-id "*" \
              --command-id RunShellScript \
              --scripts "
                set -e
                echo '=== Frontend VMSS Instance Update Start ==='
                echo 'IMAGE_TAG=${{ needs.setup.outputs.image_tag }}'
                
                # Set environment variable
                export IMAGE_TAG=${{ needs.setup.outputs.image_tag }}
                echo 'IMAGE_TAG=${{ needs.setup.outputs.image_tag }}' >> /opt/yangju-frontend/.env
                
                # Pull new images and restart service
                cd /opt/yangju-frontend
                sudo systemctl stop yangju-frontend.service
                sudo /usr/local/bin/yangju-frontend-compose-run.sh pull
                sudo systemctl start yangju-frontend.service
                
                # Wait for health check
                for i in {1..30}; do
                  if curl -fsS http://localhost:80 >/dev/null 2>&1; then
                    echo 'Frontend health check passed'
                    break
                  fi
                  echo 'Waiting for frontend health check... (\$i/30)'
                  sleep 2
                done
                
                sudo docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}'
                echo '=== Frontend VMSS Instance Update Complete ==='
              " \
              --query 'value[].message' -o tsv
            echo "âœ… Frontend VMSS deployment completed"
          else
            echo "âš ï¸ Frontend VMSS not found, skipping deployment"
          fi

  check-webapp:
    runs-on: ubuntu-latest
    needs: [setup]
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: needs.setup.outputs.should_deploy_webapp == 'true'
    outputs:
      webapp_be_exists: ${{ steps.check.outputs.webapp_be_exists }}
      webapp_fe_exists: ${{ steps.check.outputs.webapp_fe_exists }}
      webapp_configured: ${{ steps.check.outputs.webapp_configured }}
    steps:
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Check Web App existence
        id: check
        run: |
          echo "ðŸ” Checking Web App existence..."
          
          # Check if Backend Web App exists
          if az webapp show --resource-group ${{ env.AZURE_RG }} --name ${{ env.WEBAPP_BE }} >/dev/null 2>&1; then
            echo "âœ… Backend Web App (${{ env.WEBAPP_BE }}) exists"
            echo "webapp_be_exists=true" >> $GITHUB_OUTPUT
            WEBAPP_BE_EXISTS=true
          else
            echo "âŒ Backend Web App (${{ env.WEBAPP_BE }}) not found"
            echo "webapp_be_exists=false" >> $GITHUB_OUTPUT
            WEBAPP_BE_EXISTS=false
          fi
          
          # Check if Frontend Web App exists
          if az webapp show --resource-group ${{ env.AZURE_RG }} --name ${{ env.WEBAPP_FE }} >/dev/null 2>&1; then
            echo "âœ… Frontend Web App (${{ env.WEBAPP_FE }}) exists"
            echo "webapp_fe_exists=true" >> $GITHUB_OUTPUT
            WEBAPP_FE_EXISTS=true
          else
            echo "âŒ Frontend Web App (${{ env.WEBAPP_FE }}) not found"
            echo "webapp_fe_exists=false" >> $GITHUB_OUTPUT
            WEBAPP_FE_EXISTS=false
          fi
          
          # Determine if Web Apps are configured (both exist)
          if [ "$WEBAPP_BE_EXISTS" = "true" ] && [ "$WEBAPP_FE_EXISTS" = "true" ]; then
            echo "âœ… Web Apps are fully configured - VMSS deployment will be skipped"
            echo "webapp_configured=true" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ Web Apps are not fully configured - VMSS deployment will proceed"
            echo "webapp_configured=false" >> $GITHUB_OUTPUT
          fi

  deploy-webapp:
    runs-on: ubuntu-latest
    needs: [setup, build-and-push, check-webapp]
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: needs.setup.outputs.should_deploy_webapp == 'true' && needs.check-webapp.outputs.webapp_configured == 'false'
    steps:
      - name: Web App deployment notice
        run: |
          echo "ðŸ“‹ Web App Deployment Status:"
          echo "- Backend Web App (${{ env.WEBAPP_BE }}): ${{ needs.check-webapp.outputs.webapp_be_exists == 'true' && 'âœ… Exists' || 'âŒ Not found' }}"
          echo "- Frontend Web App (${{ env.WEBAPP_FE }}): ${{ needs.check-webapp.outputs.webapp_fe_exists == 'true' && 'âœ… Exists' || 'âŒ Not found' }}"
          echo ""
          echo "â„¹ï¸ Web Apps are not fully configured - proceeding with deployment setup"
          echo "â„¹ï¸ Actual Web App deployments are handled by separate build-and-push workflow"
          echo ""
          echo "ðŸŽ¯ Action: Setting up Web App configuration for future deployments"

  real-time-diagnostics:
    runs-on: ubuntu-latest
    needs: [setup, create-application-gateway, create-vmss, deploy-vmss]
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: needs.setup.outputs.should_deploy_vmss == 'true' && (needs.create-vmss.result == 'success' || needs.deploy-vmss.result == 'success')
    steps:
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Real-time VMSS Diagnostics and Validation
        run: |
          echo "ðŸ” Starting comprehensive VMSS diagnostics and validation..."
          
          # Function to run diagnostics on a VMSS instance
          run_vmss_diagnostics() {
            local vmss_name="$1"
            local test_name="$2"
            
            if ! az vmss show --resource-group ${{ env.AZURE_RG }} --name "$vmss_name" >/dev/null 2>&1; then
              echo "âš ï¸ $vmss_name not found, skipping diagnostics"
              return 1
            fi
            
            # Get first available instance
            local instance_id
            instance_id=$(az vmss list-instances \
              --resource-group ${{ env.AZURE_RG }} \
              --name "$vmss_name" \
              --query "[0].instanceId" -o tsv 2>/dev/null)
            
            if [ -z "$instance_id" ] || [ "$instance_id" = "null" ]; then
              echo "âš ï¸ No instances found for $vmss_name"
              return 1
            fi
            
            echo "ðŸ”¬ Running diagnostics on $vmss_name instance $instance_id..."
            
            az vmss run-command invoke \
              --resource-group ${{ env.AZURE_RG }} \
              --name "$vmss_name" \
              --instance-id "$instance_id" \
              --command-id RunShellScript \
              --scripts "
                echo '=== $test_name VMSS Diagnostics Report ==='
                echo 'Host: \$(hostname)'
                echo 'Date: \$(date)'
                echo 'Instance ID: $instance_id'
                echo ''
                
                # 1. System Information
                echo '1. System Information'
                echo '   OS: \$(lsb_release -d | cut -f2)'
                echo '   Kernel: \$(uname -r)'
                echo '   Uptime: \$(uptime -p)'
                echo ''
                
                # 2. Managed Identity Status
                echo '2. Managed Identity Status'
                MI_ENDPOINT='http://169.254.169.254/metadata/identity/oauth2/token'
                if curl -s -H 'Metadata:true' \"\$MI_ENDPOINT?api-version=2018-02-01&resource=https://management.azure.com/\" >/dev/null 2>&1; then
                  echo '   âœ… Managed Identity endpoint accessible'
                  
                  # Get token
                  MI_TOKEN=\$(curl -s -H 'Metadata:true' \"\$MI_ENDPOINT?api-version=2018-02-01&resource=https://management.azure.com/\" | jq -r .access_token 2>/dev/null || echo 'FAILED')
                  if [ \"\$MI_TOKEN\" != \"FAILED\" ] && [ -n \"\$MI_TOKEN\" ]; then
                    echo '   âœ… Management token acquired (length: \${#MI_TOKEN})'
                  else
                    echo '   âŒ Failed to acquire management token'
                  fi
                  
                  # Test ACR-specific token
                  ACR_TOKEN=\$(curl -s -H 'Metadata:true' \"\$MI_ENDPOINT?api-version=2018-02-01&resource=https://${{ env.ACR_NAME }}.azurecr.io\" | jq -r .access_token 2>/dev/null || echo 'FAILED')
                  if [ \"\$ACR_TOKEN\" != \"FAILED\" ] && [ -n \"\$ACR_TOKEN\" ]; then
                    echo '   âœ… ACR-specific token acquired'
                  else
                    echo '   âš ï¸ ACR-specific token acquisition failed (will use management token)'
                  fi
                else
                  echo '   âŒ Managed Identity endpoint not accessible'
                fi
                echo ''
                
                # 3. Network Connectivity
                echo '3. Network Connectivity'
                
                # DNS Resolution
                if nslookup ${{ env.ACR_NAME }}.azurecr.io >/dev/null 2>&1; then
                  ACR_IP=\$(nslookup ${{ env.ACR_NAME }}.azurecr.io | grep 'Address:' | tail -1 | awk '{print \$2}')
                  echo '   âœ… ACR DNS resolution: \$ACR_IP'
                else
                  echo '   âŒ ACR DNS resolution failed'
                fi
                
                # HTTPS Connectivity
                if curl -sSf https://${{ env.ACR_NAME }}.azurecr.io/v2/ >/dev/null 2>&1; then
                  echo '   âœ… ACR HTTPS connectivity successful'
                else
                  echo '   âŒ ACR HTTPS connectivity failed'
                fi
                
                # Key Vault connectivity (if configured)
                KV_NAME=\$(curl -s -H 'Metadata:true' 'http://169.254.169.254/metadata/instance/compute/tags?api-version=2021-01-01&format=text' | grep -o 'keyvault:[^;]*' | cut -d':' -f2 2>/dev/null || echo 'kv-bcd00')
                if [ -n \"\$KV_NAME\" ]; then
                  if nslookup \"\$KV_NAME.vault.azure.net\" >/dev/null 2>&1; then
                    echo '   âœ… Key Vault DNS resolution successful'
                  else
                    echo '   âš ï¸ Key Vault DNS resolution failed or not configured'
                  fi
                fi
                echo ''
                
                # 4. Docker Status
                echo '4. Docker Status'
                if systemctl is-active docker >/dev/null 2>&1; then
                  echo '   âœ… Docker service is active'
                  echo '   Docker version: \$(docker --version 2>/dev/null || echo \"Not available\")'
                  
                  # Docker login test
                  if [ \"\$MI_TOKEN\" != \"FAILED\" ]; then
                    echo '   Testing Docker login...'
                    if echo \"\$MI_TOKEN\" | docker login ${{ env.ACR_NAME }}.azurecr.io --username 00000000-0000-0000-0000-000000000000 --password-stdin >/dev/null 2>&1; then
                      echo '   âœ… Docker ACR login successful'
                    else
                      echo '   âŒ Docker ACR login failed'
                    fi
                  fi
                else
                  echo '   âŒ Docker service is not active'
                  systemctl status docker --no-pager -l || true
                fi
                echo ''
                
                # 5. Application Status (Backend specific)
                if [ '$test_name' = 'Backend' ]; then
                  echo '5. Application Status'
                  
                  # Check yangju service
                  if systemctl is-active yangju.service >/dev/null 2>&1; then
                    echo '   âœ… Yangju service is active'
                  else
                    echo '   âŒ Yangju service is not active'
                    systemctl status yangju.service --no-pager -l || true
                  fi
                  
                  # Health endpoint test
                  if curl -fsS http://localhost:4000/health >/dev/null 2>&1; then
                    echo '   âœ… Health endpoint responding'
                    HEALTH_DATA=\$(curl -s http://localhost:4000/health 2>/dev/null || echo '{}')
                    echo \"   Health data: \$HEALTH_DATA\" | head -c 200
                  else
                    echo '   âŒ Health endpoint not responding'
                  fi
                  
                  # Container status
                  echo '   Container status:'
                  docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}' 2>/dev/null || echo '   No containers running'
                fi
                
                # 6. Cloud-init Status
                echo ''
                echo '6. Cloud-init Status'
                if [ -f /var/log/cloud-init-output.log ]; then
                  echo '   Cloud-init log (last 10 lines):'
                  tail -10 /var/log/cloud-init-output.log | sed 's/^/     /'
                else
                  echo '   âš ï¸ Cloud-init log not found'
                fi
                
                echo ''
                echo '=== Diagnostics Complete ==='
              " \
              --query 'value[0].message' -o tsv
          }
          
          # Run diagnostics on both VMSS
          echo "Running diagnostics on Backend VMSS..."
          run_vmss_diagnostics "${{ env.VMSS_BE }}" "Backend" || echo "Backend diagnostics failed"
          
          echo ""
          echo "Running diagnostics on Frontend VMSS..."
          run_vmss_diagnostics "${{ env.VMSS_FE }}" "Frontend" || echo "Frontend diagnostics failed"

  health-check:
    runs-on: ubuntu-latest
    needs: [setup, check-vmss, check-webapp, create-application-gateway, create-vmss, deploy-vmss, deploy-webapp, real-time-diagnostics, auto-fix-vmss]
    if: always() && (needs.deploy-vmss.result == 'success' || needs.deploy-webapp.result == 'success' || needs.check-vmss.outputs.vmss_configured == 'true' || needs.check-webapp.outputs.webapp_configured == 'true')
    environment: ${{ github.event.inputs.environment || 'dev' }}
    steps:
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: VMSS Health Check
        if: needs.setup.outputs.should_deploy_vmss == 'true'
        run: |
          echo "Checking VMSS health..."
          
          # Check Application Gateway health
          AGW_NAME="agw-bcd00"
          if az network application-gateway show --resource-group ${{ env.AZURE_RG }} --name "$AGW_NAME" >/dev/null 2>&1; then
            echo "âœ… Application Gateway $AGW_NAME exists"
            
            # Get public IP
            AGW_PUBLIC_IP=$(az network public-ip show --resource-group ${{ env.AZURE_RG }} --name pip-agw-bcd00 --query "ipAddress" -o tsv)
            echo "ðŸŒ Application Gateway Public IP: $AGW_PUBLIC_IP"
            
            # Test Application Gateway endpoint
            if curl -fsS "http://$AGW_PUBLIC_IP" >/dev/null 2>&1; then
              echo "âœ… Application Gateway frontend health check passed"
            else
              echo "âš ï¸ Application Gateway frontend health check failed (may take time to be ready)"
            fi
            
            # Test backend API through Application Gateway
            if curl -fsS "http://$AGW_PUBLIC_IP/api/health" >/dev/null 2>&1; then
              echo "âœ… Application Gateway backend health check passed"
            else
              echo "âš ï¸ Application Gateway backend health check failed (may take time to be ready)"
            fi
          else
            echo "âŒ Application Gateway not found"
          fi
          
          # Check Backend VMSS instances health
          echo "Backend VMSS instances:"
          az vmss list-instances \
            --resource-group ${{ env.AZURE_RG }} \
            --name ${{ env.VMSS_BE }} \
            --query "[].{InstanceId:instanceId, ProvisioningState:provisioningState, HealthState:latestModelApplied}" \
            -o table || echo "Backend VMSS not found"
          
          # Check Frontend VMSS instances health
          echo "Frontend VMSS instances:"
          az vmss list-instances \
            --resource-group ${{ env.AZURE_RG }} \
            --name ${{ env.VMSS_FE }} \
            --query "[].{InstanceId:instanceId, ProvisioningState:provisioningState, HealthState:latestModelApplied}" \
            -o table || echo "Frontend VMSS not found"

      - name: Web App Health Check
        if: needs.setup.outputs.should_deploy_webapp == 'true'
        run: |
          echo "Checking Web App health..."
          
          # Check backend Web App
          if az webapp show --resource-group ${{ env.AZURE_RG }} --name ${{ env.WEBAPP_BE }} >/dev/null 2>&1; then
            BACKEND_URL=$(az webapp show --resource-group ${{ env.AZURE_RG }} --name ${{ env.WEBAPP_BE }} --query "defaultHostName" -o tsv)
            echo "Backend URL: https://$BACKEND_URL"
            
            # Try health endpoint
            if curl -fsS "https://$BACKEND_URL/health" >/dev/null 2>&1; then
              echo "âœ… Backend health check passed"
            else
              echo "âŒ Backend health check failed"
            fi
          fi
          
          # Check frontend Web App
          if az webapp show --resource-group ${{ env.AZURE_RG }} --name ${{ env.WEBAPP_FE }} >/dev/null 2>&1; then
            FRONTEND_URL=$(az webapp show --resource-group ${{ env.AZURE_RG }} --name ${{ env.WEBAPP_FE }} --query "defaultHostName" -o tsv)
            echo "Frontend URL: https://$FRONTEND_URL"
            
            # Try frontend endpoint
            if curl -fsS "https://$FRONTEND_URL" >/dev/null 2>&1; then
              echo "âœ… Frontend health check passed"
            else
              echo "âŒ Frontend health check failed"
            fi
          fi

  summary:
    runs-on: ubuntu-latest
    needs: [setup, build-and-push, check-vmss, check-webapp, create-application-gateway, create-vmss, deploy-vmss, deploy-webapp, health-check, auto-fix-vmss]
    if: always()
    steps:
      - name: Deployment Summary
        run: |
          echo "# ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag**: ${{ needs.setup.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment Target**: ${{ env.DEPLOYMENT_TARGET }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Resource Group**: ${{ env.AZURE_RG }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Resource Status" >> $GITHUB_STEP_SUMMARY
          echo "- **VMSS Configured**: ${{ needs.check-vmss.outputs.vmss_configured || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Web App Configured**: ${{ needs.check-webapp.outputs.webapp_configured || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Results" >> $GITHUB_STEP_SUMMARY
          echo "- **Build & Push**: ${{ needs.build-and-push.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **VMSS Creation**: ${{ needs.create-vmss.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **VMSS Deployment**: ${{ needs.deploy-vmss.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Web App Deployment**: ${{ needs.deploy-webapp.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Health Check**: ${{ needs.health-check.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Auto Fix VMSS**: ${{ needs.auto-fix-vmss.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Images" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend**: \`${{ needs.build-and-push.outputs.backend_image || 'N/A' }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend**: \`${{ needs.build-and-push.outputs.frontend_image || 'N/A' }}\`" >> $GITHUB_STEP_SUMMARY

  auto-fix-vmss:
    if: ${{ (inputs.deployment_target == 'vmss-only' || inputs.deployment_target == 'both') && always() }}
    needs: [deploy-vmss]
    runs-on: ubuntu-latest
    
    steps:
    - name: ì²´í¬ì•„ì›ƒ
      uses: actions/checkout@v4
    
    - name: Azure ë¡œê·¸ì¸
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
    
    - name: ìžë™ ë¬¸ì œ í•´ê²° ì‹¤í–‰
      id: auto-fix
      run: |
        echo "ðŸ”§ VMSS ìžë™ ë¬¸ì œ í•´ê²° ì‹œìž‘..."
        
        # ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰ ê¶Œí•œ ë¶€ì—¬
        chmod +x scripts/auto-fix-vmss.sh
        
        # ìžë™ í•´ê²° ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
        if scripts/auto-fix-vmss.sh ${{ env.AZURE_RG }} ${{ env.VMSS_BE }} ${{ env.ACR_NAME }}; then
          echo "result=success" >> $GITHUB_OUTPUT
          echo "âœ… VMSS ë¬¸ì œ ìžë™ í•´ê²° ì™„ë£Œ"
        else
          echo "result=failed" >> $GITHUB_OUTPUT
          echo "âŒ ìžë™ í•´ê²° ì‹¤íŒ¨ - ìˆ˜ë™ í™•ì¸ í•„ìš”"
          exit 1
        fi
    
    - name: ìµœì¢… ìƒíƒœ ê²€ì¦
      if: steps.auto-fix.outputs.result == 'success'
      run: |
        echo "ðŸ” ìµœì¢… ìƒíƒœ ê²€ì¦ ì¤‘..."
        
        # VMSS ìƒíƒœ í™•ì¸
        VMSS_STATE=$(az vmss show \
          --resource-group ${{ env.AZURE_RG }} \
          --name ${{ env.VMSS_BE }} \
          --query "provisioningState" -o tsv)
        
        echo "VMSS í”„ë¡œë¹„ì €ë‹ ìƒíƒœ: $VMSS_STATE"
        
        # ì¸ìŠ¤í„´ìŠ¤ ìƒíƒœ í™•ì¸
        INSTANCE_COUNT=$(az vmss list-instances \
          --resource-group ${{ env.AZURE_RG }} \
          --name ${{ env.VMSS_BE }} \
          --query "length(@)" -o tsv)
        
        echo "ì‹¤í–‰ ì¤‘ì¸ ì¸ìŠ¤í„´ìŠ¤ ìˆ˜: $INSTANCE_COUNT"
        
        if [ "$VMSS_STATE" = "Succeeded" ] && [ "$INSTANCE_COUNT" -gt 0 ]; then
          echo "âœ… VMSSê°€ ì •ìƒì ìœ¼ë¡œ ì‹¤í–‰ ì¤‘ìž…ë‹ˆë‹¤"
        else
          echo "âš ï¸ VMSS ìƒíƒœë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”"
        fi
    
    - name: ë¬¸ì œ í•´ê²° ì‹¤íŒ¨ ì‹œ ì§„ë‹¨ ì •ë³´ ì œê³µ
      if: failure()
      run: |
        echo "âŒ ìžë™ ë¬¸ì œ í•´ê²°ì´ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."
        echo ""
        echo "ë‹¤ìŒ ë‹¨ê³„ë¥¼ ìˆ˜ë™ìœ¼ë¡œ í™•ì¸í•´ì£¼ì„¸ìš”:"
        echo ""
        echo "1. ê´€ë¦¬ ID í™•ì¸:"
        echo "   az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_BE }} --query 'identity'"
        echo ""
        echo "2. ACR ê¶Œí•œ í™•ì¸:"
        echo "   az role assignment list --assignee <PRINCIPAL_ID> --scope /subscriptions/<SUBSCRIPTION_ID>/resourceGroups/${{ env.AZURE_RG }}/providers/Microsoft.ContainerRegistry/registries/${{ env.ACR_NAME }}"
        echo ""
        echo "3. NSG ê·œì¹™ í™•ì¸:"
        echo "   az network nsg rule list --resource-group ${{ env.AZURE_RG }} --nsg-name ${{ env.VMSS_BE }}-nsg"
        echo ""
        echo "4. ìˆ˜ë™ ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰:"
        echo "   ./scripts/fix-vmss-acr-issues.ps1"
