name: Deploy to Azure (VMSS + Web App)

on:
  workflow_dispatch:
    inputs:
      deployment_target:
        description: "배포 대상 선택"
        required: true
        default: "both"
        type: choice
        options:
          - both
          - vmss-only
          - webapp-only
      environment:
        description: "배포 환경"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - staging
          - prod
      image_tag:
        description: "배포할 이미지 태그 (기본: latest)"
        required: false
        type: string
        default: "latest"
  push:
    branches: [ "main" ]
    paths:
      - "Front-End/**"
      - "Back-End/**"
      - "infra/**"
      - ".github/workflows/deploy-unified.yml"

permissions:
  contents: read
  id-token: write
  actions: read

concurrency:
  group: deploy-${{ github.ref }}-${{ github.event.inputs.environment || 'dev' }}
  cancel-in-progress: false

env:
  AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
  AZURE_RG: rg-bcd00
  ACR_NAME: acrbcd00
  KV_NAME: kv-bcd00
  VMSS_BE: vmss-be-bcd00
  VMSS_FE: vmss-fe-bcd00
  WEBAPP_BE: webapp-be-bcd00
  WEBAPP_FE: webapp-fe-bcd00
  IMAGE_TAG: ${{ github.event.inputs.image_tag || 'latest' }}
  DEPLOYMENT_TARGET: ${{ github.event.inputs.deployment_target || 'both' }}
  ENVIRONMENT: ${{ github.event.inputs.environment || 'dev' }}

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      should_deploy_vmss: ${{ steps.targets.outputs.should_deploy_vmss }}
      should_deploy_webapp: ${{ steps.targets.outputs.should_deploy_webapp }}
      image_tag: ${{ steps.tags.outputs.image_tag }}
    steps:
      - name: Determine deployment targets
        id: targets
        run: |
          case "${{ env.DEPLOYMENT_TARGET }}" in
            "both")
              echo "should_deploy_vmss=true" >> $GITHUB_OUTPUT
              echo "should_deploy_webapp=true" >> $GITHUB_OUTPUT
              ;;
            "vmss-only")
              echo "should_deploy_vmss=true" >> $GITHUB_OUTPUT
              echo "should_deploy_webapp=false" >> $GITHUB_OUTPUT
              ;;
            "webapp-only")
              echo "should_deploy_vmss=false" >> $GITHUB_OUTPUT
              echo "should_deploy_webapp=true" >> $GITHUB_OUTPUT
              ;;
          esac
          
      - name: Set image tag
        id: tags
        run: |
          if [ "${{ env.IMAGE_TAG }}" = "latest" ] && [ "${{ github.event_name }}" = "push" ]; then
            SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
            echo "image_tag=sha-${SHORT_SHA}" >> $GITHUB_OUTPUT
          else
            echo "image_tag=${{ env.IMAGE_TAG }}" >> $GITHUB_OUTPUT
          fi

  build-and-push:
    runs-on: ubuntu-latest
    needs: setup
    environment: ${{ github.event.inputs.environment || 'dev' }}
    outputs:
      backend_image: ${{ steps.images.outputs.backend_image }}
      frontend_image: ${{ steps.images.outputs.frontend_image }}
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - uses: docker/setup-buildx-action@v3

      - name: ACR login
        run: az acr login --name ${{ env.ACR_NAME }}

      - name: Build and push backend
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile.backend
          push: true
          tags: |
            ${{ env.ACR_NAME }}.azurecr.io/backend:${{ needs.setup.outputs.image_tag }}
            ${{ env.ACR_NAME }}.azurecr.io/backend:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push frontend
        uses: docker/build-push-action@v6
        with:
          context: Front-End
          file: ./Dockerfile.frontend
          push: true
          tags: |
            ${{ env.ACR_NAME }}.azurecr.io/frontend:${{ needs.setup.outputs.image_tag }}
            ${{ env.ACR_NAME }}.azurecr.io/frontend:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Set image outputs
        id: images
        run: |
          echo "backend_image=${{ env.ACR_NAME }}.azurecr.io/backend:${{ needs.setup.outputs.image_tag }}" >> $GITHUB_OUTPUT
          echo "frontend_image=${{ env.ACR_NAME }}.azurecr.io/frontend:${{ needs.setup.outputs.image_tag }}" >> $GITHUB_OUTPUT

  check-vmss:
    runs-on: ubuntu-latest
    needs: [setup]
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: needs.setup.outputs.should_deploy_vmss == 'true'
    outputs:
      vmss_be_exists: ${{ steps.check.outputs.vmss_be_exists }}
      vmss_fe_exists: ${{ steps.check.outputs.vmss_fe_exists }}
      vmss_configured: ${{ steps.check.outputs.vmss_configured }}
    steps:
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Check VMSS existence
        id: check
        run: |
          echo "🔍 Checking VMSS existence..."
          
          # Check if Backend VMSS exists
          if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_BE }} >/dev/null 2>&1; then
            echo "✅ Backend VMSS (${{ env.VMSS_BE }}) exists"
            echo "vmss_be_exists=true" >> $GITHUB_OUTPUT
            VMSS_BE_EXISTS=true
          else
            echo "❌ Backend VMSS (${{ env.VMSS_BE }}) not found"
            echo "vmss_be_exists=false" >> $GITHUB_OUTPUT
            VMSS_BE_EXISTS=false
          fi
          
          # Check if Frontend VMSS exists
          if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_FE }} >/dev/null 2>&1; then
            echo "✅ Frontend VMSS (${{ env.VMSS_FE }}) exists"
            echo "vmss_fe_exists=true" >> $GITHUB_OUTPUT
            VMSS_FE_EXISTS=true
          else
            echo "❌ Frontend VMSS (${{ env.VMSS_FE }}) not found"
            echo "vmss_fe_exists=false" >> $GITHUB_OUTPUT
            VMSS_FE_EXISTS=false
          fi
          
          # Individual VMSS deployment decisions
          if [ "$VMSS_BE_EXISTS" = "false" ] || [ "$VMSS_FE_EXISTS" = "false" ]; then
            echo "⚠️ Some VMSS are missing - VMSS deployment will proceed"
            echo "vmss_configured=false" >> $GITHUB_OUTPUT
          else
            echo "✅ All VMSS are configured - VMSS deployment will be skipped"
            echo "vmss_configured=true" >> $GITHUB_OUTPUT
          fi

  deploy-infrastructure:
    runs-on: ubuntu-latest
    needs: [setup, build-and-push, check-vmss]
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: needs.setup.outputs.should_deploy_vmss == 'true' && needs.check-vmss.outputs.vmss_configured == 'false'
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Deploy infrastructure (if needed)
        run: |
          echo "Infrastructure deployment step - implement based on your bicep/terraform files"
          # az deployment group create --resource-group ${{ env.AZURE_RG }} --template-file infra/main.bicep
          echo "Skipping infrastructure deployment - using existing resources"

  create-vmss:
    runs-on: ubuntu-latest
    needs: [setup, build-and-push, deploy-infrastructure, check-vmss, setup-agw-health-probes]
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: needs.setup.outputs.should_deploy_vmss == 'true' && needs.check-vmss.outputs.vmss_configured == 'false'
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Check existing Azure resources
        run: |
          echo "🔍 Checking existing Azure resources for VMSS deployment..."
          
          # Basic subnet checks (required for VMSS)
          if az network vnet subnet show --resource-group ${{ env.AZURE_RG }} --vnet-name vnet-eus2 --name snet-eus2-be >/dev/null 2>&1; then
            echo "✅ Backend subnet (snet-eus2-be) exists"
          else
            echo "❌ Backend subnet (snet-eus2-be) not found"
            exit 1
          fi
          
          if az network vnet subnet show --resource-group ${{ env.AZURE_RG }} --vnet-name vnet-eus2 --name snet-eus2-fe >/dev/null 2>&1; then
            echo "✅ Frontend subnet (snet-eus2-fe) exists"
          else
            echo "❌ Frontend subnet (snet-eus2-fe) not found"
            exit 1
          fi
          
          echo "✅ Required networking resources verified for VMSS creation"

      - name: Create NSG with required rules (Enhanced)
        run: |
          echo "Creating NSGs for both Frontend and Backend VMSS with enhanced outbound rules..."
          
          # Create Backend NSG (skip if exists)
          if ! az network nsg show --resource-group ${{ env.AZURE_RG }} --name vmss-be-bcd00-nsg >/dev/null 2>&1; then
            echo "Creating Backend NSG..."
            az network nsg create \
              --resource-group ${{ env.AZURE_RG }} \
              --name vmss-be-bcd00-nsg \
              --location eastus2
          else
            echo "Backend NSG already exists"
          fi
          
          # Add inbound rule for port 4000 (backend application)
          az network nsg rule create \
            --resource-group ${{ env.AZURE_RG }} \
            --nsg-name vmss-be-bcd00-nsg \
            --name "Allow-AGW-Backend-4000" \
            --priority 1000 \
            --source-address-prefixes "172.16.0.0/27" \
            --destination-port-ranges "4000" \
            --access "Allow" \
            --protocol "Tcp" \
            --direction "Inbound" \
            || echo "Backend inbound NSG rule already exists"
          
          # Add critical outbound rules for ACR and Key Vault access
          az network nsg rule create \
            --resource-group ${{ env.AZURE_RG }} \
            --nsg-name vmss-be-bcd00-nsg \
            --name "Allow-HTTPS-Outbound" \
            --priority 100 \
            --source-address-prefixes "*" \
            --destination-address-prefixes "Internet" \
            --destination-port-ranges "443" \
            --access "Allow" \
            --protocol "Tcp" \
            --direction "Outbound" \
            || echo "HTTPS outbound rule already exists"
          
          # Add rule for Azure services (ACR, Key Vault, etc.)
          az network nsg rule create \
            --resource-group ${{ env.AZURE_RG }} \
            --nsg-name vmss-be-bcd00-nsg \
            --name "Allow-Azure-Services" \
            --priority 110 \
            --source-address-prefixes "*" \
            --destination-address-prefixes "AzureContainerRegistry" \
            --destination-port-ranges "443" \
            --access "Allow" \
            --protocol "Tcp" \
            --direction "Outbound" \
            || echo "Azure services outbound rule already exists"
          
          # Add rule for Key Vault access
          az network nsg rule create \
            --resource-group ${{ env.AZURE_RG }} \
            --nsg-name vmss-be-bcd00-nsg \
            --name "Allow-KeyVault-Access" \
            --priority 120 \
            --source-address-prefixes "*" \
            --destination-address-prefixes "AzureKeyVault" \
            --destination-port-ranges "443" \
            --access "Allow" \
            --protocol "Tcp" \
            --direction "Outbound" \
            || echo "Key Vault outbound rule already exists"
          
          # Create Frontend NSG (skip if exists)
          if ! az network nsg show --resource-group ${{ env.AZURE_RG }} --name vmss-fe-bcd00-nsg >/dev/null 2>&1; then
            echo "Creating Frontend NSG..."
            az network nsg create \
              --resource-group ${{ env.AZURE_RG }} \
              --name vmss-fe-bcd00-nsg \
              --location eastus2
          else
            echo "Frontend NSG already exists"
          fi
          
          # Add rule for port 80 (frontend application)
          az network nsg rule create \
            --resource-group ${{ env.AZURE_RG }} \
            --nsg-name vmss-fe-bcd00-nsg \
            --name "Allow-AGW-Frontend-80" \
            --priority 1000 \
            --source-address-prefixes "172.16.0.0/27" \
            --destination-port-ranges "80" \
            --access "Allow" \
            --protocol "Tcp" \
            --direction "Inbound" \
            || echo "Frontend NSG rule already exists"
          
          # Add SSH rules for both
          for nsg in "vmss-be-bcd00-nsg" "vmss-fe-bcd00-nsg"; do
            az network nsg rule create \
              --resource-group ${{ env.AZURE_RG }} \
              --nsg-name "$nsg" \
              --name "Allow-SSH" \
              --priority 1001 \
              --source-address-prefixes "*" \
              --destination-port-ranges "22" \
              --access "Allow" \
              --protocol "Tcp" \
              --direction "Inbound" \
              || echo "SSH rule already exists for $nsg"
          done

      - name: Create SSH Keys
        run: |
          echo "Creating SSH Keys for both VMSS..."
          
          # Create Backend SSH Key (skip if exists)
          if ! az sshkey show --resource-group ${{ env.AZURE_RG }} --name vmss-be-bcd00_key >/dev/null 2>&1; then
            echo "Creating Backend SSH key..."
            az sshkey create \
              --resource-group ${{ env.AZURE_RG }} \
              --name vmss-be-bcd00_key \
              --location eastus2
          else
            echo "Backend SSH key already exists"
          fi
          
          # Create Frontend SSH Key (skip if exists)
          if ! az sshkey show --resource-group ${{ env.AZURE_RG }} --name vmss-fe-bcd00_key >/dev/null 2>&1; then
            echo "Creating Frontend SSH key..."
            az sshkey create \
              --resource-group ${{ env.AZURE_RG }} \
              --name vmss-fe-bcd00_key \
              --location eastus2
          else
            echo "Frontend SSH key already exists"
          fi

      - name: Create VMSS instances (Enhanced with Auto Managed Identity)
        run: |
          echo "🏗️ Creating Frontend and Backend VMSS with automatic managed identity setup..."
          
          # Create User-assigned Managed Identities first
          echo "Creating User-assigned Managed Identities..."
          if ! az identity show --resource-group ${{ env.AZURE_RG }} --name id-vmss-be-bcd00 >/dev/null 2>&1; then
            echo "Creating Backend Managed Identity..."
            az identity create --resource-group ${{ env.AZURE_RG }} --name id-vmss-be-bcd00 --location eastus2
            
            # Wait for identity to be ready
            sleep 15
          else
            echo "Backend Managed Identity already exists"
          fi
          
          if ! az identity show --resource-group ${{ env.AZURE_RG }} --name id-vmss-fe-bcd00 >/dev/null 2>&1; then
            echo "Creating Frontend Managed Identity..."
            az identity create --resource-group ${{ env.AZURE_RG }} --name id-vmss-fe-bcd00 --location eastus2
            
            # Wait for identity to be ready
            sleep 15
          else
            echo "Frontend Managed Identity already exists"
          fi
          
          # Get identity resource IDs for both user-assigned and system-assigned
          VMSS_BE_IDENTITY_ID=$(az identity show --resource-group ${{ env.AZURE_RG }} --name id-vmss-be-bcd00 --query "id" -o tsv)
          VMSS_FE_IDENTITY_ID=$(az identity show --resource-group ${{ env.AZURE_RG }} --name id-vmss-fe-bcd00 --query "id" -o tsv)
          
          echo "Backend Identity ID: $VMSS_BE_IDENTITY_ID"
          echo "Frontend Identity ID: $VMSS_FE_IDENTITY_ID"
          
          # Create Backend VMSS only if it doesn't exist
          echo "🔍 Checking Backend VMSS existence..."
          if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_BE }} >/dev/null 2>&1; then
            echo "✅ Backend VMSS already exists, skipping creation"
          else
            echo "❌ Backend VMSS not found, will create"
            
            # Wait for any pending operations to complete
            echo "⏳ Waiting for any pending operations..."
            sleep 30
            
            # Double-check before creating
            if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_BE }} >/dev/null 2>&1; then
              echo "✅ Backend VMSS appeared during wait, skipping creation"
            else
              echo "Creating Backend VMSS with both user-assigned and system-assigned identities..."
              az vmss create \
                --resource-group ${{ env.AZURE_RG }} \
                --name ${{ env.VMSS_BE }} \
                --image "Canonical:0001-com-ubuntu-server-jammy:22_04-lts-gen2:latest" \
                --instance-count 2 \
                --vm-sku Standard_B2s \
                --vnet-name vnet-eus2 \
                --subnet snet-eus2-be \
                --nsg vmss-be-bcd00-nsg \
                --orchestration-mode Uniform \
                --upgrade-policy-mode automatic \
                --admin-username bcdbeuser00 \
                --generate-ssh-keys \
                --custom-data infra/cloud-init-optimized.yaml \
                --assign-identity "$VMSS_BE_IDENTITY_ID" \
                --load-balancer nlb-bcd00 \
                --backend-pool-name backend-lb-pool \
                --health-probe "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.AZURE_RG }}/providers/Microsoft.Network/loadBalancers/nlb-bcd00/probes/probe-for-port-4000" \
                --location eastus2
              
              # Also enable system-assigned identity for additional compatibility
              echo "Enabling system-assigned managed identity for Backend VMSS..."
              az vmss identity assign \
                --resource-group ${{ env.AZURE_RG }} \
                --name ${{ env.VMSS_BE }} \
                --identities [system]
              
              echo "✅ Backend VMSS created successfully with dual identity setup"
            fi
          fi
          
          # Create Frontend VMSS only if it doesn't exist
          echo "🔍 Checking Frontend VMSS existence..."
          if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_FE }} >/dev/null 2>&1; then
            echo "✅ Frontend VMSS already exists, skipping creation"
          else
            echo "❌ Frontend VMSS not found, will create"
            
            # Wait for any pending operations to complete
            echo "⏳ Waiting for any pending operations..."
            sleep 30
            
            # Double-check before creating
            if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_FE }} >/dev/null 2>&1; then
              echo "✅ Frontend VMSS appeared during wait, skipping creation"
            else
              echo "Creating Frontend VMSS with both user-assigned and system-assigned identities..."
              az vmss create \
                --resource-group ${{ env.AZURE_RG }} \
                --name ${{ env.VMSS_FE }} \
                --image "Canonical:0001-com-ubuntu-server-jammy:22_04-lts-gen2:latest" \
                --instance-count 2 \
                --vm-sku Standard_B2s \
                --vnet-name vnet-eus2 \
                --subnet snet-eus2-fe \
                --nsg vmss-fe-bcd00-nsg \
                --orchestration-mode Uniform \
                --upgrade-policy-mode automatic \
                --admin-username bcdfeuser00 \
                --generate-ssh-keys \
                --custom-data infra/cloud-init-frontend.yaml \
                --assign-identity "$VMSS_FE_IDENTITY_ID" \
                --load-balancer "" \
                --location eastus2
              
              # Also enable system-assigned identity for additional compatibility
              echo "Enabling system-assigned managed identity for Frontend VMSS..."
              az vmss identity assign \
                --resource-group ${{ env.AZURE_RG }} \
                --name ${{ env.VMSS_FE }} \
                --identities [system]
              
              echo "✅ Frontend VMSS created successfully with dual identity setup"
            fi
          fi

      - name: Validate and Re-assign Permissions (Comprehensive)
        run: |
          echo "� Comprehensive permission validation and assignment..."
          
          # Wait for identities to propagate fully
          sleep 30
          
          # Function to get all identity IDs for a VMSS
          get_vmss_identities() {
            local vmss_name="$1"
            local rg="$2"
            
            # Get user-assigned identity
            USER_IDENTITY=$(az identity show --resource-group "$rg" --name "id-$vmss_name" --query "principalId" -o tsv 2>/dev/null || echo "")
            
            # Get system-assigned identity
            SYSTEM_IDENTITY=$(az vmss show --resource-group "$rg" --name "$vmss_name" --query "identity.principalId" -o tsv 2>/dev/null || echo "")
            
            echo "USER_IDENTITY:$USER_IDENTITY SYSTEM_IDENTITY:$SYSTEM_IDENTITY"
          }
          
          # Function to assign ACR permissions
          assign_acr_permissions() {
            local identity_id="$1"
            local identity_type="$2"
            local vmss_name="$3"
            
            if [ -n "$identity_id" ] && [ "$identity_id" != "null" ]; then
              echo "Assigning ACR permissions to $identity_type identity ($identity_id) for $vmss_name..."
              
              # AcrPull role
              az role assignment create \
                --assignee "$identity_id" \
                --role "AcrPull" \
                --scope "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.AZURE_RG }}/providers/Microsoft.ContainerRegistry/registries/${{ env.ACR_NAME }}" \
                || echo "AcrPull role already assigned or failed"
              
              # AcrImageSigner for token exchange compatibility
              az role assignment create \
                --assignee "$identity_id" \
                --role "AcrImageSigner" \
                --scope "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.AZURE_RG }}/providers/Microsoft.ContainerRegistry/registries/${{ env.ACR_NAME }}" \
                || echo "AcrImageSigner role assignment skipped"
              
              # Verify assignments
              echo "Verifying ACR role assignments for $identity_type identity:"
              az role assignment list \
                --assignee "$identity_id" \
                --scope "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.AZURE_RG }}/providers/Microsoft.ContainerRegistry/registries/${{ env.ACR_NAME }}" \
                --query "[].roleDefinitionName" -o tsv | sed 's/^/   - /'
              
              return 0
            else
              echo "Warning: No valid $identity_type identity found for $vmss_name"
              return 1
            fi
          }
          
          # Function to assign Key Vault permissions
          assign_keyvault_permissions() {
            local identity_id="$1"
            local identity_type="$2"
            local vmss_name="$3"
            
            if [ -n "$identity_id" ] && [ "$identity_id" != "null" ]; then
              # Find Key Vault
              KV_NAME=$(az keyvault list --resource-group ${{ env.AZURE_RG }} --query "[0].name" -o tsv 2>/dev/null || echo "")
              
              if [ -n "$KV_NAME" ] && [ "$KV_NAME" != "null" ]; then
                echo "Assigning Key Vault permissions to $identity_type identity for $vmss_name..."
                
                # RBAC role assignment
                az role assignment create \
                  --assignee "$identity_id" \
                  --role "Key Vault Secrets User" \
                  --scope "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.AZURE_RG }}/providers/Microsoft.KeyVault/vaults/$KV_NAME" \
                  || echo "Key Vault RBAC role already assigned"
                
                # Access policy for backward compatibility
                az keyvault set-policy \
                  --name "$KV_NAME" \
                  --object-id "$identity_id" \
                  --secret-permissions get list \
                  || echo "Key Vault access policy already set"
                
                echo "✅ Key Vault permissions configured for $identity_type identity"
              else
                echo "⚠️ Key Vault not found, skipping Key Vault permissions"
              fi
            fi
          }
          
          # Process Backend VMSS identities
          echo "🔐 Processing Backend VMSS identities..."
          BACKEND_IDENTITIES=$(get_vmss_identities "${{ env.VMSS_BE }}" "${{ env.AZURE_RG }}")
          USER_BE_ID=$(echo "$BACKEND_IDENTITIES" | cut -d' ' -f1 | cut -d':' -f2)
          SYSTEM_BE_ID=$(echo "$BACKEND_IDENTITIES" | cut -d' ' -f2 | cut -d':' -f2)
          
          echo "Backend User Identity: $USER_BE_ID"
          echo "Backend System Identity: $SYSTEM_BE_ID"
          
          # Assign permissions to both identities for maximum compatibility
          BACKEND_SUCCESS=0
          if assign_acr_permissions "$USER_BE_ID" "user-assigned" "${{ env.VMSS_BE }}"; then
            assign_keyvault_permissions "$USER_BE_ID" "user-assigned" "${{ env.VMSS_BE }}"
            BACKEND_SUCCESS=1
          fi
          
          if assign_acr_permissions "$SYSTEM_BE_ID" "system-assigned" "${{ env.VMSS_BE }}"; then
            assign_keyvault_permissions "$SYSTEM_BE_ID" "system-assigned" "${{ env.VMSS_BE }}"
            BACKEND_SUCCESS=1
          fi
          
          if [ $BACKEND_SUCCESS -eq 0 ]; then
            echo "❌ Failed to assign permissions to Backend VMSS"
            exit 1
          else
            echo "✅ Backend VMSS permissions configured successfully"
          fi
          
          # Process Frontend VMSS identities
          echo "🔐 Processing Frontend VMSS identities..."
          FRONTEND_IDENTITIES=$(get_vmss_identities "${{ env.VMSS_FE }}" "${{ env.AZURE_RG }}")
          USER_FE_ID=$(echo "$FRONTEND_IDENTITIES" | cut -d' ' -f1 | cut -d':' -f2)
          SYSTEM_FE_ID=$(echo "$FRONTEND_IDENTITIES" | cut -d' ' -f2 | cut -d':' -f2)
          
          echo "Frontend User Identity: $USER_FE_ID"
          echo "Frontend System Identity: $SYSTEM_FE_ID"
          
          # Assign permissions to both identities for maximum compatibility
          FRONTEND_SUCCESS=0
          if assign_acr_permissions "$USER_FE_ID" "user-assigned" "${{ env.VMSS_FE }}"; then
            assign_keyvault_permissions "$USER_FE_ID" "user-assigned" "${{ env.VMSS_FE }}"
            FRONTEND_SUCCESS=1
          fi
          
          if assign_acr_permissions "$SYSTEM_FE_ID" "system-assigned" "${{ env.VMSS_FE }}"; then
            assign_keyvault_permissions "$SYSTEM_FE_ID" "system-assigned" "${{ env.VMSS_FE }}"
            FRONTEND_SUCCESS=1
          fi
          
          if [ $FRONTEND_SUCCESS -eq 0 ]; then
            echo "⚠️ Warning: Could not assign permissions to Frontend VMSS (may affect image pulling)"
          else
            echo "✅ Frontend VMSS permissions configured successfully"
          fi
          
          echo ""
          echo "📋 Permission Assignment Summary:"
          echo "Backend VMSS: $([ $BACKEND_SUCCESS -eq 1 ] && echo "✅ Success" || echo "❌ Failed")"
          echo "Frontend VMSS: $([ $FRONTEND_SUCCESS -eq 1 ] && echo "✅ Success" || echo "⚠️ Partial")"

      - name: Configure Application Gateway Backend Pools
        run: |
          echo "Configuring Application Gateway backend pools..."
          
          # Wait for VMSS to be fully ready
          sleep 30
          
          # Create backend pool for API calls (routed to load balancer)
          az network application-gateway address-pool create \
            --resource-group ${{ env.AZURE_RG }} \
            --gateway-name agw-bcd00 \
            --name backend-pool \
            || echo "Backend pool already exists"
          
          # Create frontend pool for web traffic (directly to frontend VMSS)
          az network application-gateway address-pool create \
            --resource-group ${{ env.AZURE_RG }} \
            --gateway-name agw-bcd00 \
            --name frontend-pool \
            || echo "Frontend pool already exists"
          
          # Configure routing rules
          echo "Configuring Application Gateway routing rules..."
          
          # Create HTTP settings for backend (port 4000 through load balancer)
          az network application-gateway http-settings create \
            --resource-group ${{ env.AZURE_RG }} \
            --gateway-name agw-bcd00 \
            --name setting-for-backend \
            --port 4000 \
            --protocol Http \
            --cookie-based-affinity Disabled \
            || echo "Backend HTTP settings already exist"
          
          # Create HTTP settings for frontend (port 80 direct to VMSS)
          az network application-gateway http-settings create \
            --resource-group ${{ env.AZURE_RG }} \
            --gateway-name agw-bcd00 \
            --name setting-for-frontend \
            --port 80 \
            --protocol Http \
            --cookie-based-affinity Disabled \
            || echo "Frontend HTTP settings already exist"
          
          # Create URL path map for routing with default path to frontend
          az network application-gateway url-path-map create \
            --resource-group ${{ env.AZURE_RG }} \
            --gateway-name agw-bcd00 \
            --name rule-path-based \
            --paths "/*" \
            --address-pool frontend-pool \
            --http-settings setting-for-frontend \
            --default-address-pool frontend-pool \
            --default-http-settings setting-for-frontend \
            || echo "URL path map already exists"
          
          # Add path rule for /api/* to backend (through load balancer)
          az network application-gateway url-path-map rule create \
            --resource-group ${{ env.AZURE_RG }} \
            --gateway-name agw-bcd00 \
            --path-map-name rule-path-based \
            --name target-backend \
            --paths "/api/*" \
            --address-pool backend-pool \
            --http-settings setting-for-backend \
            || echo "Backend path rule already exists"
            
          # Configure Frontend VMSS → Application Gateway direct connection
          echo "Configuring Frontend VMSS → Application Gateway direct connection..."
          
          # Check if Frontend VMSS exists and has instances
          if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_FE }} >/dev/null 2>&1; then
            # Get Frontend VMSS instance private IPs
            FRONTEND_IPS=$(az vmss nic list \
              --resource-group ${{ env.AZURE_RG }} \
              --vmss-name ${{ env.VMSS_FE }} \
              --query "[].ipConfigurations[0].privateIPAddress" -o tsv | tr '\n' ' ')
            
            if [ -n "$FRONTEND_IPS" ]; then
              echo "Adding Frontend VMSS IPs ($FRONTEND_IPS) to frontend pool"
              az network application-gateway address-pool update \
                --resource-group ${{ env.AZURE_RG }} \
                --gateway-name agw-bcd00 \
                --name frontend-pool \
                --servers $FRONTEND_IPS \
                || echo "Frontend IPs already added to frontend pool"
              echo "✅ Frontend VMSS → Application Gateway connection configured"
            else
              echo "⚠️ Could not find Frontend VMSS instance IPs"
            fi
          else
            echo "⚠️ Frontend VMSS not found, skipping direct connection"
          fi
          
          # Configure Backend API routing: Application Gateway → Load Balancer → Backend VMSS
          echo "Configuring Application Gateway → Load Balancer → Backend VMSS routing..."
          
          # Add load balancer frontend IP to backend pool
          NLB_FRONTEND_IP=$(az network lb frontend-ip list \
            --resource-group ${{ env.AZURE_RG }} \
            --lb-name nlb-bcd00 \
            --query "[0].privateIPAddress" -o tsv)
          
          if [ -n "$NLB_FRONTEND_IP" ] && [ "$NLB_FRONTEND_IP" != "null" ]; then
            echo "Adding Load Balancer frontend IP ($NLB_FRONTEND_IP) to backend pool"
            az network application-gateway address-pool update \
              --resource-group ${{ env.AZURE_RG }} \
              --gateway-name agw-bcd00 \
              --name backend-pool \
              --servers "$NLB_FRONTEND_IP" \
              || echo "Load balancer IP already added to backend pool"
            echo "✅ Application Gateway → Load Balancer → Backend VMSS routing configured"
          else
            echo "⚠️ Could not find load balancer frontend IP"
          fi
          
          echo "📊 Application Gateway Configuration Summary:"
          echo "  🔸 Frontend Traffic: Application Gateway → Frontend VMSS (direct)"
          echo "  🔸 Backend API Traffic: Application Gateway → Load Balancer → Backend VMSS"
          echo "  🔸 Routing: /* → Frontend Pool, /api/* → Backend Pool"

  create-application-gateway:
    runs-on: ubuntu-latest
    needs: [setup, build-and-push, deploy-infrastructure, check-vmss]
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: needs.setup.outputs.should_deploy_vmss == 'true' && needs.check-vmss.outputs.vmss_configured == 'false'
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Check and create Application Gateway if needed
        run: |
          echo "🌐 Checking Application Gateway requirements..."
          
          # Check if Application Gateway subnet exists
          if az network vnet subnet show --resource-group ${{ env.AZURE_RG }} --vnet-name vnet-eus2 --name snet-eus2-agw >/dev/null 2>&1; then
            echo "✅ Application Gateway subnet (snet-eus2-agw) exists"
            
            # Check if Application Gateway already exists
            if az network application-gateway show --resource-group ${{ env.AZURE_RG }} --name agw-bcd00 >/dev/null 2>&1; then
              echo "✅ Application Gateway (agw-bcd00) already exists"
              echo "AGW_EXISTS=true" >> $GITHUB_ENV
            else
              echo "⚠️ Application Gateway (agw-bcd00) not found - will create"
              echo "AGW_EXISTS=false" >> $GITHUB_ENV
              
              # Create Public IP for Application Gateway
              echo "Creating Public IP for Application Gateway..."
              az network public-ip create \
                --resource-group ${{ env.AZURE_RG }} \
                --name pip-agw-bcd00 \
                --allocation-method Static \
                --sku Standard \
                --location eastus2 \
                || echo "Public IP already exists"
              
              # Create Application Gateway
              echo "Creating Application Gateway..."
              az network application-gateway create \
                --resource-group ${{ env.AZURE_RG }} \
                --name agw-bcd00 \
                --location eastus2 \
                --sku Standard_v2 \
                --capacity 2 \
                --vnet-name vnet-eus2 \
                --subnet snet-eus2-agw \
                --public-ip-address pip-agw-bcd00 \
                --http-settings-cookie-based-affinity Enabled \
                --frontend-port 80 \
                --http-settings-port 80 \
                --http-settings-protocol Http \
                --priority 100
              
              echo "✅ Application Gateway created successfully"
              echo "AGW_EXISTS=true" >> $GITHUB_ENV
            fi
          else
            echo "⚠️ Application Gateway subnet (snet-eus2-agw) not found - will skip Application Gateway creation"
            echo "AGW_EXISTS=false" >> $GITHUB_ENV
          fi

  setup-agw-health-probes:
    if: ${{ inputs.deployment_target == 'vmss-only' || inputs.deployment_target == 'both' }}
    needs: [create-application-gateway]
    runs-on: ubuntu-latest
    
    steps:
    - name: 체크아웃
      uses: actions/checkout@v4
    
    - name: Azure 로그인
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
    
    - name: Application Gateway Health Probe 설정
      run: |
        echo "🏥 Application Gateway Health Probe 설정 중..."
        
        # 스크립트 실행 권한 부여
        chmod +x scripts/create-agw-health-probe.sh
        
        # Health Probe 생성 실행
        scripts/create-agw-health-probe.sh ${{ env.AZURE_RG }} agw-bcd00 || {
          echo "⚠️ Health Probe 설정에 실패했지만 배포를 계속합니다."
        }
        
        echo "✅ Application Gateway Health Probe 설정 완료"

  deploy-vmss:
    runs-on: ubuntu-latest
    needs: [setup, build-and-push, deploy-infrastructure, create-vmss, check-vmss]
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: needs.setup.outputs.should_deploy_vmss == 'true' && needs.check-vmss.outputs.vmss_configured == 'false'
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Update VMSS with optimized cloud-init
        run: |
          echo "🔄 Updating Frontend and Backend VMSS models with cloud-init..."
          
          # Update Backend VMSS if it exists
          if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_BE }} >/dev/null 2>&1; then
            echo "Updating Backend VMSS rolling upgrade policy..."
            az vmss update \
              --resource-group ${{ env.AZURE_RG }} \
              --name ${{ env.VMSS_BE }} \
              --set upgradePolicy.mode=Rolling \
              --set upgradePolicy.rollingUpgradePolicy.maxBatchInstancePercent=50 \
              --set upgradePolicy.rollingUpgradePolicy.maxUnhealthyInstancePercent=100 \
              --set upgradePolicy.rollingUpgradePolicy.maxUnhealthyUpgradedInstancePercent=100 \
              --set upgradePolicy.rollingUpgradePolicy.pauseTimeBetweenBatches=PT30S

            echo "Updating Backend VMSS model with new cloud-init..."
            az vmss update \
              --resource-group ${{ env.AZURE_RG }} \
              --name ${{ env.VMSS_BE }} \
              --set virtualMachineProfile.osProfile.customData="$(base64 -w 0 < infra/cloud-init-optimized.yaml)"
            
            echo "✅ Backend VMSS model updated"
          else
            echo "⚠️ Backend VMSS not found, skipping update"
          fi
          
          # Update Frontend VMSS if it exists
          if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_FE }} >/dev/null 2>&1; then
            echo "Adding Application Health Extension to Frontend VMSS..."
            az vmss extension set \
              --resource-group ${{ env.AZURE_RG }} \
              --vmss-name ${{ env.VMSS_FE }} \
              --name ApplicationHealthLinux \
              --publisher Microsoft.ManagedServices \
              --version 1.0 \
              --settings '{"protocol":"http","port":80,"requestPath":"/"}' \
              || echo "Application Health Extension already exists"

            echo "Updating Frontend VMSS upgrade policy to Manual (Rolling requires health probe)..."
            az vmss update \
              --resource-group ${{ env.AZURE_RG }} \
              --name ${{ env.VMSS_FE }} \
              --set upgradePolicy.mode=Manual

            echo "Updating Frontend VMSS model with new cloud-init..."
            az vmss update \
              --resource-group ${{ env.AZURE_RG }} \
              --name ${{ env.VMSS_FE }} \
              --set virtualMachineProfile.osProfile.customData="$(base64 -w 0 < infra/cloud-init-frontend.yaml)"
              
            echo "✅ Frontend VMSS model updated"
          else
            echo "⚠️ Frontend VMSS not found, skipping update"
          fi

      - name: Rolling upgrade VMSS instances
        run: |
          echo "🔄 Starting rolling upgrade of VMSS instances..."
          
          # Upgrade Backend VMSS if it exists
          if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_BE }} >/dev/null 2>&1; then
            echo "Upgrading Backend VMSS..."
            az vmss rolling-upgrade start \
              --resource-group ${{ env.AZURE_RG }} \
              --name ${{ env.VMSS_BE }} \
              || {
                echo "Rolling upgrade failed for Backend VMSS, trying instance-by-instance update..."
                INSTANCE_IDS=$(az vmss list-instances --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_BE }} --query "[].instanceId" -o tsv)
                for instance_id in $INSTANCE_IDS; do
                  echo "Updating Backend VMSS instance $instance_id..."
                  az vmss update-instances \
                    --resource-group ${{ env.AZURE_RG }} \
                    --name ${{ env.VMSS_BE }} \
                    --instance-ids $instance_id
                  sleep 30
                done
              }
            echo "✅ Backend VMSS upgrade completed"
          else
            echo "⚠️ Backend VMSS not found, skipping upgrade"
          fi
          
          # Upgrade Frontend VMSS if it exists
          if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_FE }} >/dev/null 2>&1; then
            echo "Upgrading Frontend VMSS..."
            az vmss rolling-upgrade start \
              --resource-group ${{ env.AZURE_RG }} \
              --name ${{ env.VMSS_FE }} \
              || {
                echo "Rolling upgrade failed for Frontend VMSS, trying instance-by-instance update..."
                INSTANCE_IDS=$(az vmss list-instances --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_FE }} --query "[].instanceId" -o tsv)
                for instance_id in $INSTANCE_IDS; do
                  echo "Updating Frontend VMSS instance $instance_id..."
                  az vmss update-instances \
                    --resource-group ${{ env.AZURE_RG }} \
                    --name ${{ env.VMSS_FE }} \
                    --instance-ids $instance_id
                  sleep 30
                done
              }
            echo "✅ Frontend VMSS upgrade completed"
          else
            echo "⚠️ Frontend VMSS not found, skipping upgrade"
          fi

      - name: Deploy new image to VMSS (Enhanced with diagnostics)
        run: |
          echo "🚀 Deploying image ${{ needs.setup.outputs.image_tag }} to VMSS instances with enhanced diagnostics..."
          
          # Deploy to Backend VMSS if it exists
          if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_BE }} >/dev/null 2>&1; then
            echo "Deploying to Backend VMSS with comprehensive health checks..."
            
            # Get all instance IDs
            INSTANCE_IDS=$(az vmss list-instances --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_BE }} --query "[].instanceId" -o tsv)
            
            if [ -n "$INSTANCE_IDS" ]; then
              for instance_id in $INSTANCE_IDS; do
                echo "Deploying to Backend VMSS instance $instance_id..."
                az vmss run-command invoke \
                  --resource-group ${{ env.AZURE_RG }} \
                  --name ${{ env.VMSS_BE }} \
                  --instance-id "$instance_id" \
                  --command-id RunShellScript \
                  --scripts "
                    set -e
                    echo '=== Backend VMSS Instance Update Start (Instance: $instance_id) ==='
                    echo 'IMAGE_TAG=${{ needs.setup.outputs.image_tag }}'
                    echo 'Host: \$(hostname)'
                    echo 'Date: \$(date)'
                    
                    # Check Managed Identity
                    echo '=== Managed Identity Check ==='
                    MI_TOKEN=\$(curl -s -H 'Metadata:true' 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/' | jq -r .access_token 2>/dev/null || echo 'FAILED')
                    if [ \"\$MI_TOKEN\" != \"FAILED\" ] && [ -n \"\$MI_TOKEN\" ]; then
                      echo '✅ Managed Identity token acquired'
                    else
                      echo '❌ Managed Identity token acquisition failed'
                    fi
                    
                    # Check ACR connectivity and authentication
                    echo '=== ACR Connectivity Check ==='
                    if nslookup ${{ env.ACR_NAME }}.azurecr.io >/dev/null 2>&1; then
                      echo '✅ ACR DNS resolution successful'
                    else
                      echo '❌ ACR DNS resolution failed'
                    fi
                    
                    if curl -sSf https://${{ env.ACR_NAME }}.azurecr.io/v2/ >/dev/null 2>&1; then
                      echo '✅ ACR HTTPS connectivity successful'
                    else
                      echo '❌ ACR HTTPS connectivity failed'
                    fi
                    
                    # Test ACR authentication
                    echo '=== ACR Authentication Test ==='
                    ACR_TOKEN=\$(curl -s -H 'Metadata:true' 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://${{ env.ACR_NAME }}.azurecr.io' | jq -r .access_token 2>/dev/null || echo '')
                    if [ -n \"\$ACR_TOKEN\" ] && [ \"\$ACR_TOKEN\" != \"null\" ]; then
                      echo '✅ ACR-specific token acquired'
                      if echo \"\$ACR_TOKEN\" | sudo docker login ${{ env.ACR_NAME }}.azurecr.io --username 00000000-0000-0000-0000-000000000000 --password-stdin; then
                        echo '✅ ACR authentication successful'
                      else
                        echo '⚠️ ACR authentication failed, trying fallback...'
                        # Fallback to management token
                        if [ \"\$MI_TOKEN\" != \"FAILED\" ]; then
                          echo \"\$MI_TOKEN\" | sudo docker login ${{ env.ACR_NAME }}.azurecr.io --username 00000000-0000-0000-0000-000000000000 --password-stdin || echo '❌ Fallback authentication failed'
                        fi
                      fi
                    else
                      echo '⚠️ Direct ACR token failed, using management token...'
                      if [ \"\$MI_TOKEN\" != \"FAILED\" ]; then
                        echo \"\$MI_TOKEN\" | sudo docker login ${{ env.ACR_NAME }}.azurecr.io --username 00000000-0000-0000-0000-000000000000 --password-stdin || echo '❌ Management token authentication failed'
                      fi
                    fi
                    
                    # Set environment variable
                    export IMAGE_TAG=${{ needs.setup.outputs.image_tag }}
                    echo 'IMAGE_TAG=${{ needs.setup.outputs.image_tag }}' | sudo tee -a /opt/yangju/.env
                    
                    # Pull new images and restart service
                    cd /opt/yangju
                    sudo systemctl stop yangju.service || true
                    
                    echo '=== Pulling new images ==='
                    sudo /usr/local/bin/yangju-compose-run.sh pull || {
                      echo '❌ Image pull failed, checking logs...'
                      sudo docker images | grep ${{ env.ACR_NAME }} || echo 'No ACR images found'
                      sudo journalctl -u docker -n 20 --no-pager || true
                      exit 1
                    }
                    
                    sudo systemctl start yangju.service
                    
                    # Wait for health check
                    echo '=== Application Health Check ==='
                    for i in {1..30}; do
                      if curl -fsS http://localhost:4000/health >/dev/null 2>&1; then
                        echo '✅ Backend health check passed after '\$i' attempts'
                        curl -s http://localhost:4000/health | jq . || echo 'Health endpoint returned non-JSON'
                        break
                      elif [ \$i -eq 30 ]; then
                        echo '❌ Backend health check failed after 30 attempts'
                        echo 'Container logs:'
                        sudo docker logs yangju-backend --tail 50 || echo 'No container logs available'
                        echo 'Service status:'
                        sudo systemctl status yangju.service || true
                        exit 1
                      else
                        echo 'Waiting for backend health check... ('\$i'/30)'
                        sleep 2
                      fi
                    done
                    
                    sudo docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}'
                    echo '=== Backend VMSS Instance Update Complete ==='
                  " \
                  --query 'value[].message' -o tsv || echo "❌ Instance $instance_id deployment failed"
                  
                echo "✅ Backend VMSS instance $instance_id deployment completed"
                sleep 10  # Instance 간 간격
              done
            else
              echo "❌ No running instances found in Backend VMSS"
            fi
          else
            echo "⚠️ Backend VMSS not found, skipping deployment"
          fi
          
          # Deploy to Frontend VMSS if it exists
          if az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_FE }} >/dev/null 2>&1; then
            echo "Deploying to Frontend VMSS..."
            az vmss run-command invoke \
              --resource-group ${{ env.AZURE_RG }} \
              --name ${{ env.VMSS_FE }} \
              --instance-id "*" \
              --command-id RunShellScript \
              --scripts "
                set -e
                echo '=== Frontend VMSS Instance Update Start ==='
                echo 'IMAGE_TAG=${{ needs.setup.outputs.image_tag }}'
                
                # Set environment variable
                export IMAGE_TAG=${{ needs.setup.outputs.image_tag }}
                echo 'IMAGE_TAG=${{ needs.setup.outputs.image_tag }}' >> /opt/yangju-frontend/.env
                
                # Pull new images and restart service
                cd /opt/yangju-frontend
                sudo systemctl stop yangju-frontend.service
                sudo /usr/local/bin/yangju-frontend-compose-run.sh pull
                sudo systemctl start yangju-frontend.service
                
                # Wait for health check
                for i in {1..30}; do
                  if curl -fsS http://localhost:80 >/dev/null 2>&1; then
                    echo 'Frontend health check passed'
                    break
                  fi
                  echo 'Waiting for frontend health check... (\$i/30)'
                  sleep 2
                done
                
                sudo docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}'
                echo '=== Frontend VMSS Instance Update Complete ==='
              " \
              --query 'value[].message' -o tsv
            echo "✅ Frontend VMSS deployment completed"
          else
            echo "⚠️ Frontend VMSS not found, skipping deployment"
          fi

  check-webapp:
    runs-on: ubuntu-latest
    needs: [setup]
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: needs.setup.outputs.should_deploy_webapp == 'true'
    outputs:
      webapp_be_exists: ${{ steps.check.outputs.webapp_be_exists }}
      webapp_fe_exists: ${{ steps.check.outputs.webapp_fe_exists }}
      webapp_configured: ${{ steps.check.outputs.webapp_configured }}
    steps:
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Check Web App existence
        id: check
        run: |
          echo "🔍 Checking Web App existence..."
          
          # Check if Backend Web App exists
          if az webapp show --resource-group ${{ env.AZURE_RG }} --name ${{ env.WEBAPP_BE }} >/dev/null 2>&1; then
            echo "✅ Backend Web App (${{ env.WEBAPP_BE }}) exists"
            echo "webapp_be_exists=true" >> $GITHUB_OUTPUT
            WEBAPP_BE_EXISTS=true
          else
            echo "❌ Backend Web App (${{ env.WEBAPP_BE }}) not found"
            echo "webapp_be_exists=false" >> $GITHUB_OUTPUT
            WEBAPP_BE_EXISTS=false
          fi
          
          # Check if Frontend Web App exists
          if az webapp show --resource-group ${{ env.AZURE_RG }} --name ${{ env.WEBAPP_FE }} >/dev/null 2>&1; then
            echo "✅ Frontend Web App (${{ env.WEBAPP_FE }}) exists"
            echo "webapp_fe_exists=true" >> $GITHUB_OUTPUT
            WEBAPP_FE_EXISTS=true
          else
            echo "❌ Frontend Web App (${{ env.WEBAPP_FE }}) not found"
            echo "webapp_fe_exists=false" >> $GITHUB_OUTPUT
            WEBAPP_FE_EXISTS=false
          fi
          
          # Determine if Web Apps are configured (both exist)
          if [ "$WEBAPP_BE_EXISTS" = "true" ] && [ "$WEBAPP_FE_EXISTS" = "true" ]; then
            echo "✅ Web Apps are fully configured - VMSS deployment will be skipped"
            echo "webapp_configured=true" >> $GITHUB_OUTPUT
          else
            echo "⚠️ Web Apps are not fully configured - VMSS deployment will proceed"
            echo "webapp_configured=false" >> $GITHUB_OUTPUT
          fi

  deploy-webapp:
    runs-on: ubuntu-latest
    needs: [setup, build-and-push, check-webapp]
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: needs.setup.outputs.should_deploy_webapp == 'true' && needs.check-webapp.outputs.webapp_configured == 'false'
    steps:
      - name: Web App deployment notice
        run: |
          echo "📋 Web App Deployment Status:"
          echo "- Backend Web App (${{ env.WEBAPP_BE }}): ${{ needs.check-webapp.outputs.webapp_be_exists == 'true' && '✅ Exists' || '❌ Not found' }}"
          echo "- Frontend Web App (${{ env.WEBAPP_FE }}): ${{ needs.check-webapp.outputs.webapp_fe_exists == 'true' && '✅ Exists' || '❌ Not found' }}"
          echo ""
          echo "ℹ️ Web Apps are not fully configured - proceeding with deployment setup"
          echo "ℹ️ Actual Web App deployments are handled by separate build-and-push workflow"
          echo ""
          echo "🎯 Action: Setting up Web App configuration for future deployments"

  real-time-diagnostics:
    runs-on: ubuntu-latest
    needs: [setup, create-application-gateway, create-vmss, deploy-vmss]
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: needs.setup.outputs.should_deploy_vmss == 'true' && (needs.create-vmss.result == 'success' || needs.deploy-vmss.result == 'success')
    steps:
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Real-time VMSS Diagnostics and Validation
        run: |
          echo "🔍 Starting comprehensive VMSS diagnostics and validation..."
          
          # Function to run diagnostics on a VMSS instance
          run_vmss_diagnostics() {
            local vmss_name="$1"
            local test_name="$2"
            
            if ! az vmss show --resource-group ${{ env.AZURE_RG }} --name "$vmss_name" >/dev/null 2>&1; then
              echo "⚠️ $vmss_name not found, skipping diagnostics"
              return 1
            fi
            
            # Get first available instance
            local instance_id
            instance_id=$(az vmss list-instances \
              --resource-group ${{ env.AZURE_RG }} \
              --name "$vmss_name" \
              --query "[0].instanceId" -o tsv 2>/dev/null)
            
            if [ -z "$instance_id" ] || [ "$instance_id" = "null" ]; then
              echo "⚠️ No instances found for $vmss_name"
              return 1
            fi
            
            echo "🔬 Running diagnostics on $vmss_name instance $instance_id..."
            
            az vmss run-command invoke \
              --resource-group ${{ env.AZURE_RG }} \
              --name "$vmss_name" \
              --instance-id "$instance_id" \
              --command-id RunShellScript \
              --scripts "
                echo '=== $test_name VMSS Diagnostics Report ==='
                echo 'Host: \$(hostname)'
                echo 'Date: \$(date)'
                echo 'Instance ID: $instance_id'
                echo ''
                
                # 1. System Information
                echo '1. System Information'
                echo '   OS: \$(lsb_release -d | cut -f2)'
                echo '   Kernel: \$(uname -r)'
                echo '   Uptime: \$(uptime -p)'
                echo ''
                
                # 2. Managed Identity Status
                echo '2. Managed Identity Status'
                MI_ENDPOINT='http://169.254.169.254/metadata/identity/oauth2/token'
                if curl -s -H 'Metadata:true' \"\$MI_ENDPOINT?api-version=2018-02-01&resource=https://management.azure.com/\" >/dev/null 2>&1; then
                  echo '   ✅ Managed Identity endpoint accessible'
                  
                  # Get token
                  MI_TOKEN=\$(curl -s -H 'Metadata:true' \"\$MI_ENDPOINT?api-version=2018-02-01&resource=https://management.azure.com/\" | jq -r .access_token 2>/dev/null || echo 'FAILED')
                  if [ \"\$MI_TOKEN\" != \"FAILED\" ] && [ -n \"\$MI_TOKEN\" ]; then
                    echo '   ✅ Management token acquired (length: \${#MI_TOKEN})'
                  else
                    echo '   ❌ Failed to acquire management token'
                  fi
                  
                  # Test ACR-specific token
                  ACR_TOKEN=\$(curl -s -H 'Metadata:true' \"\$MI_ENDPOINT?api-version=2018-02-01&resource=https://${{ env.ACR_NAME }}.azurecr.io\" | jq -r .access_token 2>/dev/null || echo 'FAILED')
                  if [ \"\$ACR_TOKEN\" != \"FAILED\" ] && [ -n \"\$ACR_TOKEN\" ]; then
                    echo '   ✅ ACR-specific token acquired'
                  else
                    echo '   ⚠️ ACR-specific token acquisition failed (will use management token)'
                  fi
                else
                  echo '   ❌ Managed Identity endpoint not accessible'
                fi
                echo ''
                
                # 3. Network Connectivity
                echo '3. Network Connectivity'
                
                # DNS Resolution
                if nslookup ${{ env.ACR_NAME }}.azurecr.io >/dev/null 2>&1; then
                  ACR_IP=\$(nslookup ${{ env.ACR_NAME }}.azurecr.io | grep 'Address:' | tail -1 | awk '{print \$2}')
                  echo '   ✅ ACR DNS resolution: \$ACR_IP'
                else
                  echo '   ❌ ACR DNS resolution failed'
                fi
                
                # HTTPS Connectivity
                if curl -sSf https://${{ env.ACR_NAME }}.azurecr.io/v2/ >/dev/null 2>&1; then
                  echo '   ✅ ACR HTTPS connectivity successful'
                else
                  echo '   ❌ ACR HTTPS connectivity failed'
                fi
                
                # Key Vault connectivity (if configured)
                KV_NAME=\$(curl -s -H 'Metadata:true' 'http://169.254.169.254/metadata/instance/compute/tags?api-version=2021-01-01&format=text' | grep -o 'keyvault:[^;]*' | cut -d':' -f2 2>/dev/null || echo 'kv-bcd00')
                if [ -n \"\$KV_NAME\" ]; then
                  if nslookup \"\$KV_NAME.vault.azure.net\" >/dev/null 2>&1; then
                    echo '   ✅ Key Vault DNS resolution successful'
                  else
                    echo '   ⚠️ Key Vault DNS resolution failed or not configured'
                  fi
                fi
                echo ''
                
                # 4. Docker Status
                echo '4. Docker Status'
                if systemctl is-active docker >/dev/null 2>&1; then
                  echo '   ✅ Docker service is active'
                  echo '   Docker version: \$(docker --version 2>/dev/null || echo \"Not available\")'
                  
                  # Docker login test
                  if [ \"\$MI_TOKEN\" != \"FAILED\" ]; then
                    echo '   Testing Docker login...'
                    if echo \"\$MI_TOKEN\" | docker login ${{ env.ACR_NAME }}.azurecr.io --username 00000000-0000-0000-0000-000000000000 --password-stdin >/dev/null 2>&1; then
                      echo '   ✅ Docker ACR login successful'
                    else
                      echo '   ❌ Docker ACR login failed'
                    fi
                  fi
                else
                  echo '   ❌ Docker service is not active'
                  systemctl status docker --no-pager -l || true
                fi
                echo ''
                
                # 5. Application Status (Backend specific)
                if [ '$test_name' = 'Backend' ]; then
                  echo '5. Application Status'
                  
                  # Check yangju service
                  if systemctl is-active yangju.service >/dev/null 2>&1; then
                    echo '   ✅ Yangju service is active'
                  else
                    echo '   ❌ Yangju service is not active'
                    systemctl status yangju.service --no-pager -l || true
                  fi
                  
                  # Health endpoint test
                  if curl -fsS http://localhost:4000/health >/dev/null 2>&1; then
                    echo '   ✅ Health endpoint responding'
                    HEALTH_DATA=\$(curl -s http://localhost:4000/health 2>/dev/null || echo '{}')
                    echo \"   Health data: \$HEALTH_DATA\" | head -c 200
                  else
                    echo '   ❌ Health endpoint not responding'
                  fi
                  
                  # Container status
                  echo '   Container status:'
                  docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}' 2>/dev/null || echo '   No containers running'
                fi
                
                # 6. Cloud-init Status
                echo ''
                echo '6. Cloud-init Status'
                if [ -f /var/log/cloud-init-output.log ]; then
                  echo '   Cloud-init log (last 10 lines):'
                  tail -10 /var/log/cloud-init-output.log | sed 's/^/     /'
                else
                  echo '   ⚠️ Cloud-init log not found'
                fi
                
                echo ''
                echo '=== Diagnostics Complete ==='
              " \
              --query 'value[0].message' -o tsv
          }
          
          # Run diagnostics on both VMSS
          echo "Running diagnostics on Backend VMSS..."
          run_vmss_diagnostics "${{ env.VMSS_BE }}" "Backend" || echo "Backend diagnostics failed"
          
          echo ""
          echo "Running diagnostics on Frontend VMSS..."
          run_vmss_diagnostics "${{ env.VMSS_FE }}" "Frontend" || echo "Frontend diagnostics failed"

  health-check:
    runs-on: ubuntu-latest
    needs: [setup, check-vmss, check-webapp, create-application-gateway, create-vmss, deploy-vmss, deploy-webapp, real-time-diagnostics, auto-fix-vmss]
    if: always() && (needs.deploy-vmss.result == 'success' || needs.deploy-webapp.result == 'success' || needs.check-vmss.outputs.vmss_configured == 'true' || needs.check-webapp.outputs.webapp_configured == 'true')
    environment: ${{ github.event.inputs.environment || 'dev' }}
    steps:
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: VMSS Health Check
        if: needs.setup.outputs.should_deploy_vmss == 'true'
        run: |
          echo "Checking VMSS health..."
          
          # Check Application Gateway health
          AGW_NAME="agw-bcd00"
          if az network application-gateway show --resource-group ${{ env.AZURE_RG }} --name "$AGW_NAME" >/dev/null 2>&1; then
            echo "✅ Application Gateway $AGW_NAME exists"
            
            # Get public IP
            AGW_PUBLIC_IP=$(az network public-ip show --resource-group ${{ env.AZURE_RG }} --name pip-agw-bcd00 --query "ipAddress" -o tsv)
            echo "🌐 Application Gateway Public IP: $AGW_PUBLIC_IP"
            
            # Test Application Gateway endpoint
            if curl -fsS "http://$AGW_PUBLIC_IP" >/dev/null 2>&1; then
              echo "✅ Application Gateway frontend health check passed"
            else
              echo "⚠️ Application Gateway frontend health check failed (may take time to be ready)"
            fi
            
            # Test backend API through Application Gateway
            if curl -fsS "http://$AGW_PUBLIC_IP/api/health" >/dev/null 2>&1; then
              echo "✅ Application Gateway backend health check passed"
            else
              echo "⚠️ Application Gateway backend health check failed (may take time to be ready)"
            fi
          else
            echo "❌ Application Gateway not found"
          fi
          
          # Check Backend VMSS instances health
          echo "Backend VMSS instances:"
          az vmss list-instances \
            --resource-group ${{ env.AZURE_RG }} \
            --name ${{ env.VMSS_BE }} \
            --query "[].{InstanceId:instanceId, ProvisioningState:provisioningState, HealthState:latestModelApplied}" \
            -o table || echo "Backend VMSS not found"
          
          # Check Frontend VMSS instances health
          echo "Frontend VMSS instances:"
          az vmss list-instances \
            --resource-group ${{ env.AZURE_RG }} \
            --name ${{ env.VMSS_FE }} \
            --query "[].{InstanceId:instanceId, ProvisioningState:provisioningState, HealthState:latestModelApplied}" \
            -o table || echo "Frontend VMSS not found"

      - name: Web App Health Check
        if: needs.setup.outputs.should_deploy_webapp == 'true'
        run: |
          echo "Checking Web App health..."
          
          # Check backend Web App
          if az webapp show --resource-group ${{ env.AZURE_RG }} --name ${{ env.WEBAPP_BE }} >/dev/null 2>&1; then
            BACKEND_URL=$(az webapp show --resource-group ${{ env.AZURE_RG }} --name ${{ env.WEBAPP_BE }} --query "defaultHostName" -o tsv)
            echo "Backend URL: https://$BACKEND_URL"
            
            # Try health endpoint
            if curl -fsS "https://$BACKEND_URL/health" >/dev/null 2>&1; then
              echo "✅ Backend health check passed"
            else
              echo "❌ Backend health check failed"
            fi
          fi
          
          # Check frontend Web App
          if az webapp show --resource-group ${{ env.AZURE_RG }} --name ${{ env.WEBAPP_FE }} >/dev/null 2>&1; then
            FRONTEND_URL=$(az webapp show --resource-group ${{ env.AZURE_RG }} --name ${{ env.WEBAPP_FE }} --query "defaultHostName" -o tsv)
            echo "Frontend URL: https://$FRONTEND_URL"
            
            # Try frontend endpoint
            if curl -fsS "https://$FRONTEND_URL" >/dev/null 2>&1; then
              echo "✅ Frontend health check passed"
            else
              echo "❌ Frontend health check failed"
            fi
          fi

  summary:
    runs-on: ubuntu-latest
    needs: [setup, build-and-push, check-vmss, check-webapp, create-application-gateway, create-vmss, deploy-vmss, deploy-webapp, health-check, auto-fix-vmss]
    if: always()
    steps:
      - name: Deployment Summary
        run: |
          echo "# 🚀 Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag**: ${{ needs.setup.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment Target**: ${{ env.DEPLOYMENT_TARGET }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Resource Group**: ${{ env.AZURE_RG }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Resource Status" >> $GITHUB_STEP_SUMMARY
          echo "- **VMSS Configured**: ${{ needs.check-vmss.outputs.vmss_configured || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Web App Configured**: ${{ needs.check-webapp.outputs.webapp_configured || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Results" >> $GITHUB_STEP_SUMMARY
          echo "- **Build & Push**: ${{ needs.build-and-push.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **VMSS Creation**: ${{ needs.create-vmss.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **VMSS Deployment**: ${{ needs.deploy-vmss.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Web App Deployment**: ${{ needs.deploy-webapp.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Health Check**: ${{ needs.health-check.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Auto Fix VMSS**: ${{ needs.auto-fix-vmss.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Images" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend**: \`${{ needs.build-and-push.outputs.backend_image || 'N/A' }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend**: \`${{ needs.build-and-push.outputs.frontend_image || 'N/A' }}\`" >> $GITHUB_STEP_SUMMARY

  auto-fix-vmss:
    if: ${{ (inputs.deployment_target == 'vmss-only' || inputs.deployment_target == 'both') && always() }}
    needs: [deploy-vmss]
    runs-on: ubuntu-latest
    
    steps:
    - name: 체크아웃
      uses: actions/checkout@v4
    
    - name: Azure 로그인
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
    
    - name: 자동 문제 해결 실행
      id: auto-fix
      run: |
        echo "🔧 VMSS 자동 문제 해결 시작..."
        
        # 스크립트 실행 권한 부여
        chmod +x scripts/auto-fix-vmss.sh
        
        # 자동 해결 스크립트 실행
        if scripts/auto-fix-vmss.sh ${{ env.AZURE_RG }} ${{ env.VMSS_BE }} ${{ env.ACR_NAME }}; then
          echo "result=success" >> $GITHUB_OUTPUT
          echo "✅ VMSS 문제 자동 해결 완료"
        else
          echo "result=failed" >> $GITHUB_OUTPUT
          echo "❌ 자동 해결 실패 - 수동 확인 필요"
          exit 1
        fi
    
    - name: 최종 상태 검증
      if: steps.auto-fix.outputs.result == 'success'
      run: |
        echo "🔍 최종 상태 검증 중..."
        
        # VMSS 상태 확인
        VMSS_STATE=$(az vmss show \
          --resource-group ${{ env.AZURE_RG }} \
          --name ${{ env.VMSS_BE }} \
          --query "provisioningState" -o tsv)
        
        echo "VMSS 프로비저닝 상태: $VMSS_STATE"
        
        # 인스턴스 상태 확인
        INSTANCE_COUNT=$(az vmss list-instances \
          --resource-group ${{ env.AZURE_RG }} \
          --name ${{ env.VMSS_BE }} \
          --query "length(@)" -o tsv)
        
        echo "실행 중인 인스턴스 수: $INSTANCE_COUNT"
        
        if [ "$VMSS_STATE" = "Succeeded" ] && [ "$INSTANCE_COUNT" -gt 0 ]; then
          echo "✅ VMSS가 정상적으로 실행 중입니다"
        else
          echo "⚠️ VMSS 상태를 확인해주세요"
        fi
    
    - name: 문제 해결 실패 시 진단 정보 제공
      if: failure()
      run: |
        echo "❌ 자동 문제 해결이 실패했습니다."
        echo ""
        echo "다음 단계를 수동으로 확인해주세요:"
        echo ""
        echo "1. 관리 ID 확인:"
        echo "   az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_BE }} --query 'identity'"
        echo ""
        echo "2. ACR 권한 확인:"
        echo "   az role assignment list --assignee <PRINCIPAL_ID> --scope /subscriptions/<SUBSCRIPTION_ID>/resourceGroups/${{ env.AZURE_RG }}/providers/Microsoft.ContainerRegistry/registries/${{ env.ACR_NAME }}"
        echo ""
        echo "3. NSG 규칙 확인:"
        echo "   az network nsg rule list --resource-group ${{ env.AZURE_RG }} --nsg-name ${{ env.VMSS_BE }}-nsg"
        echo ""
        echo "4. 수동 스크립트 실행:"
        echo "   ./scripts/fix-vmss-acr-issues.ps1"
