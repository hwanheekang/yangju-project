name: Deploy to Azure (VMSS + Web App)

on:
  workflow_dispatch:
    inputs:
      deployment_target:
        description: "배포 대상 선택"
        required: true
        default: "both"
        type: choice
        options:
          - both
          - vmss-only
          - webapp-only
      environment:
        description: "배포 환경"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - staging
          - prod
      image_tag:
        description: "배포할 이미지 태그 (기본: latest)"
        required: false
        type: string
        default: "latest"
  push:
    branches: [ "main" ]
    paths:
      - "Front-End/**"
      - "Back-End/**"
      - "infra/**"
      - ".github/workflows/deploy-unified.yml"

permissions:
  contents: read
  id-token: write
  actions: read

concurrency:
  group: deploy-${{ github.ref }}-${{ github.event.inputs.environment || 'dev' }}
  cancel-in-progress: false

env:
  AZURE_SUBSCRIPTION_ID: ${{ vars.AZURE_SUBSCRIPTION_ID }}
  AZURE_RG: rg-bcd00
  ACR_NAME: acrbcd00
  VMSS_BE: vmss-be-bcd00
  VMSS_FE: vmss-fe-bcd00
  WEBAPP_BE: app-be-bcd00
  WEBAPP_FE: app-fe-bcd00
  IMAGE_TAG: ${{ github.event.inputs.image_tag || 'latest' }}
  DEPLOYMENT_TARGET: ${{ github.event.inputs.deployment_target || 'both' }}
  ENVIRONMENT: ${{ github.event.inputs.environment || 'dev' }}

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      should_deploy_vmss: ${{ steps.targets.outputs.should_deploy_vmss }}
      should_deploy_webapp: ${{ steps.targets.outputs.should_deploy_webapp }}
      image_tag: ${{ steps.tags.outputs.image_tag }}
    steps:
      - name: Determine deployment targets
        id: targets
        run: |
          case "${{ env.DEPLOYMENT_TARGET }}" in
            "both")
              echo "should_deploy_vmss=true" >> $GITHUB_OUTPUT
              echo "should_deploy_webapp=true" >> $GITHUB_OUTPUT
              ;;
            "vmss-only")
              echo "should_deploy_vmss=true" >> $GITHUB_OUTPUT
              echo "should_deploy_webapp=false" >> $GITHUB_OUTPUT
              ;;
            "webapp-only")
              echo "should_deploy_vmss=false" >> $GITHUB_OUTPUT
              echo "should_deploy_webapp=true" >> $GITHUB_OUTPUT
              ;;
          esac
          
      - name: Set image tag
        id: tags
        run: |
          if [ "${{ env.IMAGE_TAG }}" = "latest" ] && [ "${{ github.event_name }}" = "push" ]; then
            SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
            echo "image_tag=sha-${SHORT_SHA}" >> $GITHUB_OUTPUT
          else
            echo "image_tag=${{ env.IMAGE_TAG }}" >> $GITHUB_OUTPUT
          fi

  build-and-push:
    runs-on: ubuntu-latest
    needs: setup
    environment: ${{ github.event.inputs.environment || 'dev' }}
    outputs:
      backend_image: ${{ steps.images.outputs.backend_image }}
      frontend_image: ${{ steps.images.outputs.frontend_image }}
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - uses: docker/setup-buildx-action@v3

      - name: ACR login
        run: az acr login --name ${{ env.ACR_NAME }}

      - name: Build and push backend
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.backend
          push: true
          tags: |
            ${{ env.ACR_NAME }}.azurecr.io/backend:${{ needs.setup.outputs.image_tag }}
            ${{ env.ACR_NAME }}.azurecr.io/backend:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push frontend
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.frontend
          push: true
          tags: |
            ${{ env.ACR_NAME }}.azurecr.io/frontend:${{ needs.setup.outputs.image_tag }}
            ${{ env.ACR_NAME }}.azurecr.io/frontend:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Set image outputs
        id: images
        run: |
          echo "backend_image=${{ env.ACR_NAME }}.azurecr.io/backend:${{ needs.setup.outputs.image_tag }}" >> $GITHUB_OUTPUT
          echo "frontend_image=${{ env.ACR_NAME }}.azurecr.io/frontend:${{ needs.setup.outputs.image_tag }}" >> $GITHUB_OUTPUT

  deploy-infrastructure:
    runs-on: ubuntu-latest
    needs: [setup, build-and-push]
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: needs.setup.outputs.should_deploy_vmss == 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Deploy infrastructure (if needed)
        run: |
          echo "Infrastructure deployment step - implement based on your bicep/terraform files"
          # az deployment group create --resource-group ${{ env.AZURE_RG }} --template-file infra/main.bicep

      - name: Configure VMSS Managed Identity permissions
        run: |
          # Get VMSS Managed Identity
          VMSS_IDENTITY=$(az vmss show --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_BE }} --query "identity.principalId" -o tsv)
          
          if [ -n "$VMSS_IDENTITY" ]; then
            echo "Configuring permissions for VMSS Managed Identity: $VMSS_IDENTITY"
            
            # Grant AcrPull role
            az role assignment create \
              --assignee "$VMSS_IDENTITY" \
              --role "AcrPull" \
              --scope "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.AZURE_RG }}/providers/Microsoft.ContainerRegistry/registries/${{ env.ACR_NAME }}" \
              || echo "AcrPull role already assigned or failed"
            
            # Grant Key Vault Secrets User role  
            KV_NAME=$(az keyvault list --resource-group ${{ env.AZURE_RG }} --query "[0].name" -o tsv)
            if [ -n "$KV_NAME" ]; then
              az role assignment create \
                --assignee "$VMSS_IDENTITY" \
                --role "Key Vault Secrets User" \
                --scope "/subscriptions/${{ env.AZURE_SUBSCRIPTION_ID }}/resourceGroups/${{ env.AZURE_RG }}/providers/Microsoft.KeyVault/vaults/$KV_NAME" \
                || echo "Key Vault role already assigned or failed"
            fi
          fi

  deploy-vmss:
    runs-on: ubuntu-latest
    needs: [setup, build-and-push, deploy-infrastructure]
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: needs.setup.outputs.should_deploy_vmss == 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Update VMSS with optimized cloud-init
        run: |
          echo "Updating VMSS model with cloud-init..."
          
          # Update rolling upgrade policy for better success rate
          az vmss update \
            --resource-group ${{ env.AZURE_RG }} \
            --name ${{ env.VMSS_BE }} \
            --set upgradePolicy.mode=Rolling \
            --set upgradePolicy.rollingUpgradePolicy.maxBatchInstancePercent=50 \
            --set upgradePolicy.rollingUpgradePolicy.maxUnhealthyInstancePercent=100 \
            --set upgradePolicy.rollingUpgradePolicy.maxUnhealthyUpgradedInstancePercent=100 \
            --set upgradePolicy.rollingUpgradePolicy.pauseTimeBetweenBatches=PT30S

          # Update VMSS model with new cloud-init
          az vmss update \
            --resource-group ${{ env.AZURE_RG }} \
            --name ${{ env.VMSS_BE }} \
            --set virtualMachineProfile.osProfile.customData="$(base64 -w 0 < infra/cloud-init-optimized.yaml)"

      - name: Rolling upgrade VMSS instances
        run: |
          echo "Starting rolling upgrade of VMSS instances..."
          
          # Start rolling upgrade
          az vmss rolling-upgrade start \
            --resource-group ${{ env.AZURE_RG }} \
            --name ${{ env.VMSS_BE }}
          
          # Wait for upgrade completion
          az vmss rolling-upgrade get-latest \
            --resource-group ${{ env.AZURE_RG }} \
            --name ${{ env.VMSS_BE }} \
            --query "runningStatus" -o tsv
          
          # Alternative: Update specific instances if rolling upgrade fails
          if [ $? -ne 0 ]; then
            echo "Rolling upgrade failed, trying instance-by-instance update..."
            INSTANCE_IDS=$(az vmss list-instances --resource-group ${{ env.AZURE_RG }} --name ${{ env.VMSS_BE }} --query "[].instanceId" -o tsv)
            for instance_id in $INSTANCE_IDS; do
              echo "Updating instance $instance_id..."
              az vmss update-instances \
                --resource-group ${{ env.AZURE_RG }} \
                --name ${{ env.VMSS_BE }} \
                --instance-ids $instance_id
              sleep 30
            done
          fi

      - name: Deploy new image to VMSS
        run: |
          echo "Deploying image ${{ needs.setup.outputs.image_tag }} to VMSS instances..."
          
          # Run deployment command on all instances
          az vmss run-command invoke \
            --resource-group ${{ env.AZURE_RG }} \
            --name ${{ env.VMSS_BE }} \
            --instance-id "*" \
            --command-id RunShellScript \
            --scripts "
              set -e
              echo '=== VMSS Instance Update Start ==='
              echo 'IMAGE_TAG=${{ needs.setup.outputs.image_tag }}'
              
              # Set environment variable
              export IMAGE_TAG=${{ needs.setup.outputs.image_tag }}
              echo 'IMAGE_TAG=${{ needs.setup.outputs.image_tag }}' >> /opt/yangju/.env
              
              # Pull new images and restart service
              cd /opt/yangju
              sudo systemctl stop yangju.service
              sudo /usr/local/bin/yangju-compose-run.sh pull
              sudo systemctl start yangju.service
              
              # Wait for health check
              for i in {1..30}; do
                if curl -fsS http://localhost:4000/health >/dev/null 2>&1; then
                  echo 'Health check passed'
                  break
                fi
                echo 'Waiting for health check... (\$i/30)'
                sleep 2
              done
              
              sudo docker ps --format 'table {{.Names}}\t{{.Image}}\t{{.Status}}'
              echo '=== VMSS Instance Update Complete ==='
            " \
            --query 'value[].message' -o tsv

  deploy-webapp:
    runs-on: ubuntu-latest
    needs: [setup, build-and-push]
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: needs.setup.outputs.should_deploy_webapp == 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Deploy to Azure Web App (Backend)
        run: |
          echo "Deploying backend to Azure Web App..."
          
          # Check if Web App exists
          if az webapp show --resource-group ${{ env.AZURE_RG }} --name ${{ env.WEBAPP_BE }} >/dev/null 2>&1; then
            # Configure Web App container
            az webapp config container set \
              --resource-group ${{ env.AZURE_RG }} \
              --name ${{ env.WEBAPP_BE }} \
              --container-image-name ${{ needs.build-and-push.outputs.backend_image }} \
              --container-registry-url https://${{ env.ACR_NAME }}.azurecr.io
            
            # Restart Web App
            az webapp restart --resource-group ${{ env.AZURE_RG }} --name ${{ env.WEBAPP_BE }}
            
            echo "Backend deployed to Web App: ${{ env.WEBAPP_BE }}"
          else
            echo "Web App ${{ env.WEBAPP_BE }} not found, skipping deployment"
          fi

      - name: Deploy to Azure Web App (Frontend)
        run: |
          echo "Deploying frontend to Azure Web App..."
          
          # Check if Web App exists
          if az webapp show --resource-group ${{ env.AZURE_RG }} --name ${{ env.WEBAPP_FE }} >/dev/null 2>&1; then
            # Configure Web App container
            az webapp config container set \
              --resource-group ${{ env.AZURE_RG }} \
              --name ${{ env.WEBAPP_FE }} \
              --container-image-name ${{ needs.build-and-push.outputs.frontend_image }} \
              --container-registry-url https://${{ env.ACR_NAME }}.azurecr.io
            
            # Restart Web App
            az webapp restart --resource-group ${{ env.AZURE_RG }} --name ${{ env.WEBAPP_FE }}
            
            echo "Frontend deployed to Web App: ${{ env.WEBAPP_FE }}"
          else
            echo "Web App ${{ env.WEBAPP_FE }} not found, skipping deployment"
          fi

  health-check:
    runs-on: ubuntu-latest
    needs: [setup, deploy-vmss, deploy-webapp]
    if: always() && (needs.deploy-vmss.result == 'success' || needs.deploy-webapp.result == 'success')
    environment: ${{ github.event.inputs.environment || 'dev' }}
    steps:
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: VMSS Health Check
        if: needs.setup.outputs.should_deploy_vmss == 'true'
        run: |
          echo "Checking VMSS health..."
          
          # Check Load Balancer health
          LB_NAME=$(az network lb list --resource-group ${{ env.AZURE_RG }} --query "[0].name" -o tsv)
          if [ -n "$LB_NAME" ]; then
            az network lb show --resource-group ${{ env.AZURE_RG }} --name "$LB_NAME" --query "backendAddressPools[0].backendIpConfigurations[].{State:provisioningState}" -o table
          fi
          
          # Check VMSS instances health
          az vmss list-instances \
            --resource-group ${{ env.AZURE_RG }} \
            --name ${{ env.VMSS_BE }} \
            --query "[].{InstanceId:instanceId, ProvisioningState:provisioningState, HealthState:latestModelApplied}" \
            -o table

      - name: Web App Health Check
        if: needs.setup.outputs.should_deploy_webapp == 'true'
        run: |
          echo "Checking Web App health..."
          
          # Check backend Web App
          if az webapp show --resource-group ${{ env.AZURE_RG }} --name ${{ env.WEBAPP_BE }} >/dev/null 2>&1; then
            BACKEND_URL=$(az webapp show --resource-group ${{ env.AZURE_RG }} --name ${{ env.WEBAPP_BE }} --query "defaultHostName" -o tsv)
            echo "Backend URL: https://$BACKEND_URL"
            
            # Try health endpoint
            if curl -fsS "https://$BACKEND_URL/health" >/dev/null 2>&1; then
              echo "✅ Backend health check passed"
            else
              echo "❌ Backend health check failed"
            fi
          fi
          
          # Check frontend Web App
          if az webapp show --resource-group ${{ env.AZURE_RG }} --name ${{ env.WEBAPP_FE }} >/dev/null 2>&1; then
            FRONTEND_URL=$(az webapp show --resource-group ${{ env.AZURE_RG }} --name ${{ env.WEBAPP_FE }} --query "defaultHostName" -o tsv)
            echo "Frontend URL: https://$FRONTEND_URL"
            
            # Try frontend endpoint
            if curl -fsS "https://$FRONTEND_URL" >/dev/null 2>&1; then
              echo "✅ Frontend health check passed"
            else
              echo "❌ Frontend health check failed"
            fi
          fi

  summary:
    runs-on: ubuntu-latest
    needs: [setup, build-and-push, deploy-vmss, deploy-webapp, health-check]
    if: always()
    steps:
      - name: Deployment Summary
        run: |
          echo "# 🚀 Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag**: ${{ needs.setup.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment Target**: ${{ env.DEPLOYMENT_TARGET }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Resource Group**: ${{ env.AZURE_RG }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Results" >> $GITHUB_STEP_SUMMARY
          echo "- **Build & Push**: ${{ needs.build-and-push.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **VMSS Deployment**: ${{ needs.deploy-vmss.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Web App Deployment**: ${{ needs.deploy-webapp.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Health Check**: ${{ needs.health-check.result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Images" >> $GITHUB_STEP_SUMMARY
          echo "- **Backend**: \`${{ needs.build-and-push.outputs.backend_image || 'N/A' }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend**: \`${{ needs.build-and-push.outputs.frontend_image || 'N/A' }}\`" >> $GITHUB_STEP_SUMMARY
